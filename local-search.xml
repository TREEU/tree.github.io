<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SDF</title>
    <link href="/2023/10/24/sdf/"/>
    <url>/2023/10/24/sdf/</url>
    
    <content type="html"><![CDATA[<p>最近工作需求安排要摸一个 sdf</p><h1 id="SDF"><a href="#SDF" class="headerlink" title="SDF"></a>SDF</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><ul><li>快</li><li>需要大量的存储</li></ul><p>距离场</p><p>二维平面上我们说物体的表面就是物体的轮廓</p><p>sdf 是一个安全距离 在此期间都不会发生碰撞</p><p>sdf 考虑的是场景中的任意一个点</p><p>每个像素记录自己与距离自己最近的物体边界的距离</p><p>符号体现在像素点在物体内距离为负 刚好在物体边界上为 0 大于为正数</p><h1 id="生成算法"><a href="#生成算法" class="headerlink" title="生成算法"></a>生成算法</h1><p>目前找到的在 CPU 上能够在线性时间内（时间复杂度 O(n)）将二值图转换为 sdf 图的算法有两种</p><p>我们必须理解的一个前提</p><p>当前像素点里面是存了初始化的距离值的 0 &#x2F; 无穷大</p><p>当前像素点的 sdf &#x3D; min(当前像素点的 sdf，目标点的 sdf + distance(像素点，目标点))</p><p>这个距离就是点与点之间的距离</p><p>(x - x’)^2 + (y - y’)^2</p><h2 id="8ssedt"><a href="#8ssedt" class="headerlink" title="8ssedt"></a>8ssedt</h2><p>算法核心思路</p><h3 id="1、创建两个网格"><a href="#1、创建两个网格" class="headerlink" title="1、创建两个网格"></a>1、创建两个网格</h3><p>遍历位图</p><ul><li><p>Grid1 用于计算物体外到物体内到距离 标记白色像素距离为 0 黑色像素为一个超大数</p></li><li><p>Grid2 用于计算物体内到物体外的距离 白色像素距离为超大数 黑色像素为 0</p></li></ul><p>推导过程是一个像素分别和周边的八个像素进行比较</p><p>为每个网格都执行一遍 pass0 和 pass1</p><ul><li>pass0 按照从上到下 从左到右 从右到左</li><li>pass1 按照从下到上 从右到左 从左到右</li></ul><p>然后将 Grid1 - Grid2 就得到了最终的结果</p><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_41835314/article/details/128548073">https://blog.csdn.net/qq_41835314/article/details/128548073</a><br><a href="https://zhuanlan.zhihu.com/p/518292475">https://zhuanlan.zhihu.com/p/518292475</a></p><h2 id="欧几里得距离算法"><a href="#欧几里得距离算法" class="headerlink" title="欧几里得距离算法"></a>欧几里得距离算法</h2><p>同样也是分为两个表格</p><p>二维情况下 像素(x,y)到形状的距离</p><p>可以拆分为两个一维操作</p><p>也就是</p><p><img src="/2023/10/24/sdf/2023-11-30-00-42-06.png"></p><p>这里我们可以发现这是一个二次函数 一个抛物线函数</p><p><img src="/2023/10/24/sdf/2023-11-30-00-45-30.png"></p><p>然后我们要做什么 我们可以从图中看出 蓝色区域就是我们可能的距离值</p><p><img src="/2023/10/24/sdf/2023-11-30-00-51-51.png"></p><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/651108382?utm_psn=1710953023390494720">https://zhuanlan.zhihu.com/p/651108382?utm_psn=1710953023390494720</a></p><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><h3 id="mipmap"><a href="#mipmap" class="headerlink" title="mipmap"></a>mipmap</h3><p>主图按特定比例缩小细节的复制品</p><p>也就是预先就生成了不同尺寸的小副本， 用于加快渲染</p><p><a href="https://zh.wikipedia.org/zh-sg/Mipmap">https://zh.wikipedia.org/zh-sg/Mipmap</a></p><h2 id="位图和矢量图"><a href="#位图和矢量图" class="headerlink" title="位图和矢量图"></a>位图和矢量图</h2><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>像素阵列，jpe.png 之类的</p><h3 id="矢量图"><a href="#矢量图" class="headerlink" title="矢量图"></a>矢量图</h3><p>矢量图保存的是对图案内容的抽象描述，而不是具体的每个像素的颜色信息</p><p>例如：svg</p><p>我们在这里生成的 sdf 也就是矢量图</p><h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>也就是将矢量图数据转换为位图数据的过程</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>系统学习算法</title>
    <link href="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    <url>/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>最近懒散了很多<br>重新考虑了目前的情况<br>决定进行系统的学习算法<br>并且希望以后能够从事算法的行业<br>我希望我当下的这份决心能和我坚持减肥一样 能够长期保持下来</p><p><strong>不做依附任何人的藤蔓</strong></p><p>目前是准备看左程云老师 b 站<br><a href="https://www.bilibili.com/video/BV13g41157hK?p=3&vd_source=cce0370852a05575ac787ef99b1d8903">https://www.bilibili.com/video/BV13g41157hK?p=3&amp;vd_source=cce0370852a05575ac787ef99b1d8903</a></p><h1 id="第一节课"><a href="#第一节课" class="headerlink" title="第一节课"></a>第一节课</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>首先我们知道评价一个算法的好坏程度是通过时间复杂度</p><p>时间复杂度也就是随着样本数量增加，算法所要花费的时间</p><p>只保留最高阶的项，并忽略系数</p><p>大 O 表示法是一个上限，数据量大的情况</p><p>同样时间复杂度的情况就需要考虑常数项</p><p>这样就需要实验进行对比，比如 console.time</p><h2 id="常数时间的操作"><a href="#常数时间的操作" class="headerlink" title="常数时间的操作"></a>常数时间的操作</h2><p>其实就是耗时不会随着样本数量产生变化，跟数据量无关，是一个固定时间操作</p><p>比如 我们从数组从取出某个数，我们不关心这个数组有多大，我们只关心 index 是多少，数组是一个连续的区域，做数组寻址</p><p>像加减乘除位运算这些都是常数操作</p><p>什么情况下不是常数复杂度呢</p><p>比如我们现在用的是链表，链表中我们要 get 某个数，我们就得要遍历，那这个链表的数据大小就会影响时间复杂度，链表不是一个连续的结构，你不知道 next 指针指到哪里所以需要遍历</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>有限几个变量就能完成这个算法流程，那就是 O(1)的</p><p>如果我要开辟一个额外数组</p><p>那就是 O(n)</p><h2 id="选择排序的时间复杂度和空间复杂度"><a href="#选择排序的时间复杂度和空间复杂度" class="headerlink" title="选择排序的时间复杂度和空间复杂度"></a>选择排序的时间复杂度和空间复杂度</h2><p>tips：</p><ul><li>首先做题的时候，我们要思考一些特殊情况，一些干扰情况</li><li>复习 array.splice(start,deklNum,startReplaceEl)</li></ul><p>选择排序这里给出的例子是 双指针 升序这么一个例子</p><p>这里补充一下选择排序是什么</p><ul><li>选择排序是一种最直观的排序</li><li>首选我们关注一下重点 这个重点是排序，也就是选择排序也是排序的一种方式<br>这个选择排序就是从数组中遍历找到最小&#x2F;最大的数，定下来，然后再遍历剩余的数据，再继续找<br>这样就是一个等差数列 时间复杂度就是 O(n^2)</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从目前给出的例子来看，冒泡排序就是遍历 然后前后比较交换位置 确定最后一位 再遍历 再交换位置 再确定一位<br>也就是我们先搞定 n-1 的数 然后搞定 n-2 的数 然后这么一直遍历确认 最终得到最终结果<br>所以最终还是等差数列<br>最终保留最高项，忽略系数 我们还是得到 O(n^2) 的时间复杂度<br>冒泡排序也是两次 for 循环 冒泡排序每次确定的都是最后一位 所以变量从 length-1 开始</p><p>咱们这里就得复习一下这个解构赋值处理数组的交换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>[arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>]] = [arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">2</span>]];<br><span class="hljs-comment">// arr [2, 3, 3]</span><br></code></pre></td></tr></table></figure><h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算 ^"></a>异或运算 ^</h2><p>这里补充讲解了异或运算</p><p>咱们就是说之前对这部分完全是 0 接触</p><p>js 其实完全也是能做这些二进制的运算的</p><p>异或运算 相同为 0 不同为 1</p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-09-12-23-07-02.png"></p><h3 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h3><p>0 ^ N &#x3D; N</p><p>N ^ N &#x3D; 0</p><p>满足交换律和结合律</p><ul><li><p>交换律 a ^ b &#x3D; b ^ a</p></li><li><p>结合律 (a ^ b) ^ c &#x3D; a ^ (b ^ c)</p></li></ul><h3 id="运算场景"><a href="#运算场景" class="headerlink" title="运算场景"></a>运算场景</h3><p>当前这里用于交换两个数的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">17</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">23</span>;<br>a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;<br><span class="hljs-comment">//  完成交换 好牛 抖机灵的写法 别这么干</span><br><span class="hljs-comment">// 这样就没有中间值这一处理了 就不用申请额外的空间了 前提 a，b指向的是两个不同的内存 如果相同就会触发N^N变成0了</span><br></code></pre></td></tr></table></figure><p>为什么？？</p><p>这里其实就是特质的运用</p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-09-12-23-56-54.png"></p><p>插播：今天解决了图片上传失效问题 使用方法为最后一项 <a href="https://hexo.io/zh-cn/docs/asset-folders.html">https://hexo.io/zh-cn/docs/asset-folders.html</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个数组</p><ul><li>只有一种数出现了奇数次 其他的所有数都是偶数次，怎么找到奇数次的数</li><li>两种数出现了奇数次 其他的数为偶数次，怎么样找到这两种数</li></ul><p>要求时间复杂度 O(n) 空间复杂度 O(1)</p><p>（js 的话就 indexOf 加一个数组对象{‘num’:次数}来处理）</p><p>哈哈哈 让我们看看神奇的异或操作怎么写</p><h2 id="第一题解答"><a href="#第一题解答" class="headerlink" title="第一题解答"></a>第一题解答</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> test = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<br><span class="hljs-keyword">let</span> eor = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; test.<span class="hljs-property">length</span>; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// eor = eor ^ test[i];</span><br>eor ^= test[i];<br>&#125;<br><span class="hljs-comment">// eor = 3</span><br></code></pre></td></tr></table></figure><p>为什么是这样<br>首先我们知道异或运算是不考虑位置关系的<br>所以这个数组在我们眼里可以看为 <code>[1,1,2,2,3,3,3]</code><br>再想想上面的性质 n^n &#x3D; 0 0 ^n &#x3D; n</p><h2 id="为什么异或满足交换律和结合律"><a href="#为什么异或满足交换律和结合律" class="headerlink" title="为什么异或满足交换律和结合律"></a>为什么异或满足交换律和结合律</h2><p>用无进位相加来看（？？）</p><p>最终的结果和 1 的位置有关，和顺序无关</p><p>这里其实就是异或运算的原理 反正就是 <strong>相同为 0 不同为 1</strong> 跟顺序其实没有什么关系</p><h2 id="第二道题解法"><a href="#第二道题解法" class="headerlink" title="第二道题解法"></a>第二道题解法</h2><p>前置知识：</p><ul><li><p>js 进制之间的转换 又忘记了<br>这里首先我们得知道进制之间的转换是发生在数字之间的 所以一定是 Number 下的方法</p><ul><li><code>Number.parseInt(string,radix)</code><ul><li>需要注意 parseInt 只能低进制转高进制，也就是二进制转八进制，八进制不能转二进制</li></ul></li><li><code>Number.toString(radix)</code><ul><li>需要注意 toString 是只能把十进制数字转换为其他进制的数字 radix 取值 2 ～ 36</li></ul></li></ul><p>另外我们还需要的知道的是 js 要么只能把其他进制转换为十进制，要么就是将十进制转换为其他进制，也可以理解为十进制是一个中间媒介</p><p>比如我们看下面这个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0xa</span>; <span class="hljs-comment">// 16进制 会被转换为十进制数字 为10 bcdef+1</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">010</span>; <span class="hljs-comment">// 8进制 会被转换为十进制 为8</span><br></code></pre></td></tr></table></figure></li><li><p>取反 <code>~</code> 1011 取反 0100</p><ul><li>js 里面是取反得到的结果就是-(x+1)</li></ul></li><li><p>取反+1 <code>~+1</code> 这里的 ➕1 是进位的意思</p></li><li><p>按位与 <code>&amp;</code> 都为 1 结果位才为 1，任何数字与 0 进行安位与都是 0</p></li></ul><p>这个第二题也比较巧妙</p><p>这个里面有一串神奇的代码<br>提取出最右边一个 1 来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> eor = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i += <span class="hljs-number">1</span>) &#123;<br>eor ^= arr[i];<br>&#125;<br><span class="hljs-comment">// 此时我们的eor = a^b</span><br><span class="hljs-comment">// a != b 所以 eor != 0 根据相同为0 不同为1 所以eor 必然在某一位上的位置上1</span><br><span class="hljs-keyword">const</span> rightone = eor &amp; (~eor + <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 我们找到这个1 然后按照这个1 将数组数据再次分堆</span><br><span class="hljs-keyword">let</span> onlyone = <span class="hljs-number">0</span>; <span class="hljs-comment">//也就是eor‘</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span>; j += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 拿到这一位为0的 进行异或操作</span><br><span class="hljs-keyword">if</span> ((arr[j] &amp; rightone) === <span class="hljs-number">0</span>) &#123;<br>onlyone ^= arr[kj];<br>&#125;<br>&#125;<br><span class="hljs-comment">// 这里也就是 onlyone^otherone^onlyone = 0 ^ otherone = otherone</span><br><span class="hljs-keyword">let</span> otherone = eor ^ onlyone;<br></code></pre></td></tr></table></figure><p><strong>位运算效率非常高</strong></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的效率比选择排序和冒泡排序的效率都要更高一些</p><p>因为选择排序和冒泡排序都是严格的 O(n^2)，插入排序跟数据的初始排序还有些关系</p><p>这个老师用拿牌模拟了一下场景 确实很像<br>也就是拿到一张牌后 遍历去找对应的位置</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>默认第一个元素已经是排好序的</li><li>取下一个元素 与以排好序的元素数组进行遍历比较 根据条件交换位置，并且插入</li><li>重复以上步骤</li></ul><p>所以插入排序最差的情况的时间复杂度是 O(n^2), 算法的时间复杂度一律按最差的情况来估计</p><p>补充知识</p><ul><li>还有平均和最好的表示方式， 大 O 是最差的情况</li></ul><p>这里其实就是初始是 0-0 然后 0-i 要进行排序</p><h2 id="补充二分查找"><a href="#补充二分查找" class="headerlink" title="补充二分查找"></a>补充二分查找</h2><p>首先使用二分法有一个明显条件，<strong>当前这个列表有序</strong><br>不过即使无序也可以使用二分-&gt;题目二 大部分都是有序情况<br>找到这个中间的数 跟目标数进行对比 如果根据大小判断是往左边找还是往右边找<br>然后再次进行二分重复当前步骤<br>时间复杂度 O(log2N) 对数 求幂的逆运算 不写底数的话默认底数为 2</p><p>只要是有序一定考虑二分</p><ul><li><p>题目一<br>在一个有序数组中，找&gt;&#x3D;某个数最左侧的位置</p></li><li><p>题目二<br>局部最小值 其实还是二分 找这个局部最小<br>数组无效 相邻数不相等 局部最小 小于两边的数 时间复杂度最小 O(n)</p></li><li><p>优化方向<br>1、数据状况优化<br>2、根据当前的特殊问题优化 比如上题 跟左右范围有关所以考虑二分</p></li></ul><h2 id="对数器的概念和使用"><a href="#对数器的概念和使用" class="headerlink" title="对数器的概念和使用"></a>对数器的概念和使用</h2><p>方法 a （想测的）<br>方法 b （好实现，时间复杂度不行）</p><p>随机样本产生器</p><p>在方法 a 中跑一遍再到方法 b 中跑一遍</p><p>这里介绍了生成随机数组的一个方法，主要就是 math.random</p><p><code>Math.random()</code> 返回[0,1) 等概率返回一个小数<br>衍生一下<br><code>Math.random() * N</code> 返回[0,N)<br><code>parseInt(Math.randow() * N)</code> 返回 [0,N-1] parseInt 会向下取整</p><h1 id="第二课"><a href="#第二课" class="headerlink" title="第二课"></a>第二课</h1><p>老师讲得真的很好 还是得静下心来啊</p><h2 id="递归行为"><a href="#递归行为" class="headerlink" title="递归行为"></a>递归行为</h2><ul><li>题目 求数组 Arr 上的最大值</li></ul><p>防止溢出的做法</p><ul><li>本来我们应该是这样写 <code>mid = (l+r)/2</code></li><li>防止溢出所以我们应该是这样写 <code>mid = l + (r - l)/2</code></li><li>然后再优化一下 右移一位 <code>(r-l) &gt;&gt; 1</code> 就是&#x2F;2 比直接&#x2F;2 要快</li></ul><p>这里给了一个递归求最大值的案例<br>贴一个伪代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getMax</span>(<span class="hljs-params">arr</span>) &#123;<br><span class="hljs-keyword">const</span> max = <span class="hljs-title function_">process</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-property">lenghth</span> - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> max;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">arr, l, r</span>) &#123;<br><span class="hljs-keyword">if</span> (l === r) &#123;<br><span class="hljs-keyword">return</span> arr[l];<br>&#125;<br><span class="hljs-keyword">let</span> mid = arr[(l + (r - l)) &gt;&gt; <span class="hljs-number">1</span>];<br><span class="hljs-keyword">let</span> leftMax = <span class="hljs-title function_">process</span>(arr, l, mid);<br><span class="hljs-keyword">let</span> rightMax = <span class="hljs-title function_">process</span>(arr, mid + <span class="hljs-number">1</span>, r);<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(leftMax, rightMax);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来去分解这个递归 我们把递归做一个分解 同时递归 &#x3D; 数学归纳法<br>发现其实就是一种进栈出栈（难怪说递归基本上都能改写为栈模式）<br>在一个高度上进行压栈</p><h2 id="master-公式的使用"><a href="#master-公式的使用" class="headerlink" title="master 公式的使用"></a>master 公式的使用</h2><h3 id="master-公式用来干嘛的"><a href="#master-公式用来干嘛的" class="headerlink" title="master 公式用来干嘛的"></a>master 公式用来干嘛的</h3><p>用来求解时间复杂度的</p><p><code>T(n) = a * T(n/b) + O(n^d)</code></p><p>母问题 n 个 数据 &#x3D; a 调用次数 * n&#x2F;b 子问题的规模 + 除子问题外剩下的过程</p><p>这个子问题的规模也就是我们把母问题的数据如何拆分 比如上述题目 我们是拆分为 1&#x2F;2 * n 调用两次</p><p><strong>要满足 master 公式的重要条件是 子问题的规模数量要相同</strong></p><p>logb^a &lt; d &#x3D;&#x3D;&#x3D; O(N^d)</p><p>logb^a &gt; d &#x3D;&#x3D;&#x3D; O(N^logb^a)</p><p>logb^a &#x3D; d &#x3D;&#x3D;&#x3D; O(N^d * logN)</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul><li>1、左边排好序</li><li>2、右边排好序</li><li>3、整合<br>这个整合 我们准备一个辅助空间 准备两个指针 把左右两边进行比较 拷贝小的 如果相等就拿左边的 也就是移动左边的指针</li></ul><p>先递归二分，再 merge，merge 的时候考虑边界，也就是哪个指针先走完</p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-07-22-52-54.png"></p><p>为什么说 O(n^2)的不好，是因为大量的比较只能确定一个数，太浪费了</p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><ul><li>小和问题</li></ul><p>这个题目也就是给你一个数组 [3,2,1] 找到数组中每个值前面比它小的值，然后累加起来</p><p>这个题目 up 主给出的思路</p><p>转换一下想法 找当前这个数 右侧比它大的数据</p><p><code>[1,3,4,2,5]</code></p><p>以当前数组作为例子<br>依次看<br>1 后面有四个数都比它大 1<em>4<br>3 后面有两个数比它大 2</em>3<br>…</p><p>使用归并排序 然后在 merge 的时候 记录小和数据</p><p>注意点 左组数与右组数指针指向的值数量相等的时候，要保证右组先拷贝，其实也就是两边都排好序了，然后我以左侧作为基准，在右边去找，这样才是准确的</p><p><strong>唯一区别 上述的是找左边的</strong></p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-07-23-52-04.png"></p><ul><li>逆序对问题<br>在一个数组中，左边的数如果比右边的数大，这两个数据构成一个逆序对，同样的问题</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li><p>荷兰国旗问题（问题 2，因为为什么叫这个名字，因为荷兰国旗有三种）</p></li><li><p>&lt;1&gt; 给定一个数组 arr，和一个数 num，请把小于等于 num 的数放在数组的左边，大于 num 的数放在数组的右边</p></li><li><p>&lt;2&gt; 给定一个数组 arr，和一个数 num，请把小于 num 的数放在数组的左边，等于 num 的放中间，大于 num 的数放在数组右边</p></li></ul><p><strong>重点：没有说要有序</strong></p><p>这两个问题的不同点在于区间的设置</p><ul><li><p>问题 1 中我们只需要一个区间，小于区间</p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-08-23-52-56.png"></p></li><li><p>问题 2 中我们需要两个区间，小于区间和大于区间，所以中间必定是小于等于 num 的<br><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-08-23-53-31.png"></p></li></ul><h2 id="快排-1-0"><a href="#快排-1-0" class="headerlink" title="快排 1.0"></a>快排 1.0</h2><p>在一个范围内 拿最后一个数做划分然后交换这个数和第一个大于这个数的位置，递归重复处理这个过程<br><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-08-23-57-00.png"></p><h2 id="快排-2-0"><a href="#快排-2-0" class="headerlink" title="快排 2.0"></a>快排 2.0</h2><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-08-23-59-20.png"></p><p>和荷兰国旗一致，2.0 版本会更快</p><p>快排的时间复杂度 logO(n^2) 因为存在最差的情况</p><p>快排 1.0 和快排 2.0 的时间复杂度都是 O(n^2)<br>最差的情况就是 123456789 这样</p><p>快排 1.0 和 2.0 都是拿最后一个值做划分值<br>所以最坏的情况就是 123456 这种 那每次只有左边的区域有效，右边都没用</p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-23-23-21-08.png"></p><h2 id="快排-3-0-O-n-logn"><a href="#快排-3-0-O-n-logn" class="headerlink" title="快排 3.0 O(n*logn)"></a>快排 3.0 O(n*logn)</h2><p>使用 master 公式我们可以得到</p><p>当我们的选取的这个点 打到中间的情况是最好的</p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-23-23-23-12.png"></p><p>这个情况 n &#x3D; 2 * (n&#x2F;2) + O(n^1) (分区需要排序一次，分区就是上面荷兰的问题)</p><p>这个时候是最好的 也就是 O(n*logn)</p><p>选取的这个值偏左或者偏右都不好</p><p>快排 3.0 随机选一个数 把它跟最右边的数做交换</p><p>快排的空间复杂度 logN 级别</p><p>最差是 O(n)</p><p>递归 递归帮你压栈<br>迭代 迭代要自己压栈</p><h1 id="第三课"><a href="#第三课" class="headerlink" title="第三课"></a>第三课</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆结构<br>完全二叉树</p><p>满的 或者是从左往右是在变满的，就是完全二叉树，也就是不能跳过左边的<br>考虑一个数组 我们把它作为一个完全二叉树，将索引记录为二叉树的值<br>那么位置关系是怎样的</p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-23-23-24-15.png"></p><p>我们目前说的位置关系也是索引的</p><p>已知索引位置 i<br>左边：2<em>i+1<br>右边：2</em>i+2<br>父：Math.floor（i-1 &#x2F; 2）</p><h3 id="堆是什么"><a href="#堆是什么" class="headerlink" title="堆是什么"></a>堆是什么</h3><p>堆是一个完全二叉树，是一个特殊的完全二叉树</p><h3 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h3><p>完全二叉树 子树 -&gt; 从根节点出发 下面的都要，每一颗子节点的最大值就是根节点的值，也就是根节点都是最大的</p><h3 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h3><p>每一个子树的最小值都是根节点的值</p><p>将数组生成一个大根堆的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 已知某个数正处在index的位置 向上继续移动</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">heapInsert</span>(<span class="hljs-params">arr: [], index: string</span>) &#123;<br><span class="hljs-comment">// 循环 如果当前的数大于当前父节点的数</span><br><span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) &#123;<br><span class="hljs-comment">// 交换数据的值</span><br><span class="hljs-title function_">swap</span>(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 索引往上穿透</span><br>index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>题目 1：找到找到大根堆中的最大值，并且删掉该最大值</li></ul><p>解答：</p><ul><li>大根堆中的最大值肯定是第一个，让数组中的第一个和最后一个交换</li><li>然后从上往下去找子节点 比较最大的子节点与根结点的值 进行 index 的向下穿透</li><li>直到没有可比较的节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 某个数在index位置 能否往下移动</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">arr: [], index: number, heapsize: number</span>) &#123;<br><span class="hljs-keyword">let</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 结束点是最后一个数 已知堆的总长度 那么最后一个数</span><br><span class="hljs-comment">// 左子节点一定比右子节点小 这里其实就在判断我是否有子节点</span><br><span class="hljs-keyword">while</span> (left &lt; heapsize) &#123;<br><span class="hljs-comment">// 继续进行迭代 获取左右孩子的最大值时 首先要考虑不能越界 也就是有没有右子节点</span><br><span class="hljs-keyword">const</span> lasterst =<br>left + <span class="hljs-number">1</span> &lt; heapsize &amp;&amp; arr[left] &gt; arr[left + <span class="hljs-number">1</span>] ? left : left + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 比较值的大小</span><br>largest = arr[largest] &gt; arr[index] ? largest : index;<br><span class="hljs-comment">// 如果当前这个最大的就是index所在的值，那就不用往下找了</span><br><span class="hljs-keyword">if</span> (lasterst === index) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 进行交换 值交换 索引位置交换 往下走</span><br><span class="hljs-title function_">swap</span>(arr, lasterst, index);<br>index = lasters;<br><span class="hljs-comment">// 重新获取left 新的左子节点</span><br>left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 补充一个swap</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">arr: [], index1, index2</span>) &#123;<br><span class="hljs-keyword">const</span> tmp = arr[index1];<br>arr[index1] = arr[index2];<br>arr[index2] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>进度：47:53</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>控制反转和依赖注入</title>
    <link href="/2023/09/07/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    <url>/2023/09/07/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="Ioc-是什么"><a href="#Ioc-是什么" class="headerlink" title="Ioc 是什么"></a>Ioc 是什么</h2><p><code>inversion of control</code> 控制反转</p><p>一种设计 用于降低代码间的耦合</p><p>提供一个容器进行依赖对象的创建和查找</p><p>例：<br>A 类在构造方法中使用了 B 类的实例<br>此时我们突然需要在 B 类的构造方法中增加方法<br>那么我们就需要在 AB 类中都增加参数</p><ul><li>这里有一个常用的简单解耦做法就是把 B 的实例直接作为参数传给 A 的构造函数</li></ul><p>如何基于 TypeScript 实现控制反转</p><p>在本篇文章中介绍了容器这个概念</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>为什么叫控制反转？<br>更多</p><p>zhihu.com</p><p>如何基于 TypeScript 实现控制反转<br>图片来源：<a href="https://bz.zzzmh.cn/">https://bz.zzzmh.cn/</a> 本文作者：陈光通一. 前言最近接到任务，需要给团队封装一个基于 EggJS 的上层 NodeJS 框架，在这个过程中参考了 NestJS 、Midway 等开源项目，发现它们都引入了一项重要特性 ——…<br>18:05</p><p>18:05</p><h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><p>如何基于 TypeScript 实现控制反转</p><h2 id="Ioc-是什么-1"><a href="#Ioc-是什么-1" class="headerlink" title="Ioc 是什么"></a>Ioc 是什么</h2><p><code>inversion of control</code> 控制反转</p><p>一种设计 用于降低代码间的耦合</p><p>提供一个容器进行依赖对象的创建和查找</p><p>例：<br>A 类在构造方法中使用了 B 类的实例<br>此时我们突然需要在 B 类的构造方法中增加方法<br>那么我们就需要在 AB 类中都增加参数</p><ul><li>这里有一个常用的简单解耦做法就是把 B 的实例直接作为参数传给 A 的构造函数</li></ul><p>在本篇文章中介绍了容器这个概念</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对依赖对象进行创建和查找</p><p>这个简单来说就像一个固定功能的盒子</p><p>方便你放相同的东西进去，和拿东西</p><p>当前文章下我们这里的东西就是 ‘类’</p><p>所以我们容器要能够去获取’类’，和注册类</p><h3 id="容器的数据结构"><a href="#容器的数据结构" class="headerlink" title="容器的数据结构"></a>容器的数据结构</h3><p>这里我们认为容器是一个 map 结构</p><p>那我们的注册就是 set</p><p>获取就是 get</p><p>这里会看起来更麻烦就是我们 set 的时候还得写个别名</p><p>但是如果代码很多的话还是没什么问题</p><p>控制反转 &#x3D; 设置一个容器 提供一个空间 能够进行 get 和 set</p><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p>依赖注入</p><p>Ioc 是一种设计规则</p><p>DI 依赖注入是具体实现的方法</p><p><strong>将依赖注入给调用方 而不需要调用方主动获取</strong></p><p>还是以目前文章中的例子来看</p><p>我们需要解决的是两个问题</p><ul><li>需要 set 的类能够自动进行 set</li><li>在 IOC 容器中的类实例化时可以直接拿到依赖对象的实例</li></ul><p>在前端我们可以使用 TS 的装饰器来实现</p><p>在此之前我们先了解一下什么是装饰器</p><h2 id="装饰器类别"><a href="#装饰器类别" class="headerlink" title="装饰器类别"></a>装饰器类别</h2><p>咱们这个装饰器还分好多种</p><ul><li><p>类装饰器</p><p>顾名思义啊 这个就是用来装饰类的<br>这里什么是装饰？ 这里其实就是用于额外的修改类</p><ul><li>比如增加静态属性</li></ul><p>这里也就是说 类装饰器就是一个对类进行处理的函数，只是写法有些不同，默认参数就是目标类</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">@decorator<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br>A = <span class="hljs-title function_">decorator</span>(A) || A;<br></code></pre></td></tr></table></figure><p>一个参数如果不够用，我们需要加一些额外的参数，就再拿函数包一层</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testable</span>(<span class="hljs-params">isTestable</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) &#123;<br>target.<span class="hljs-property">isTestable</span> = isTestable;<br>target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isTestable1</span> = isTestable;<br>&#125;;<br>&#125;<br><br>@<span class="hljs-title function_">testable</span>(ture)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><span class="hljs-comment">// A.isTestable = true</span><br><span class="hljs-comment">// 如果想增加实例属性</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();<br><span class="hljs-comment">// a.isTestable1 = true</span><br></code></pre></td></tr></table></figure><p>实际上很好理解,把装饰理解为修改就行，装饰器就是一个函数，一定要有的参数就是当前我们想操作的目标</p><p>也可以直接返回一个新类做替换</p><ul><li>方法装饰器<br>基本上和类装饰器一致</li></ul><p>还有几个其他的装饰器</p><p>装饰器只能用于类和类的方法，不能用于函数，因为函数存在函数提升</p><p>这里函数提升不要忘记了 函数声明 <code>function aa()&#123;&#125;</code> 是存在函数提升的，但是函数表达式是没有提升的 <code>const aa = function()&#123;&#125;</code></p><p>暂时我们了解到这里又可以回到我们的文章中，咱又能看了</p><p>到这里就懂了，这个依赖注入其实就是字面意思 依赖的注入 使用装饰器</p><p>实际上这样在开发中感觉并不太直观</p><p>我们以大佬的举例来看，实际用闭包做，功能性和性能都可以等价</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">@<span class="hljs-title function_">logging</span>(debug)<br>@<span class="hljs-title function_">auth</span>(admin)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserInfo</span>(<span class="hljs-params"></span>)&#123;&#125;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserInfo</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-title function_">logging</span>(debug, <span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-title function_">auth</span>(admin, <span class="hljs-function">() =&gt;</span> &#123;<br>           <span class="hljs-comment">// getUserInfo本来的业务逻辑</span><br>       &#125;)<br>   &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那就到这里，容器还是一个很好的概念 集中化处理<br>简单做法，直接将类作为参数进行传参<br>高效学习意味着对学习的集中性，信息的有效筛选，以及知识的吸收和运用</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js-leecode</title>
    <link href="/2023/07/19/js-leecode/"/>
    <url>/2023/07/19/js-leecode/</url>
    
    <content type="html"><![CDATA[<h1 id="记录力扣上刷的-js-题的知识点"><a href="#记录力扣上刷的-js-题的知识点" class="headerlink" title="记录力扣上刷的 js 题的知识点"></a>记录力扣上刷的 js 题的知识点</h1><blockquote><p>无知并不可怕 可怕的是一直无知</p></blockquote><h2 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="headerlink" title="for.. in.. 和 for .. of 的区别"></a>for.. in.. 和 for .. of 的区别</h2><p>简单来说</p><ul><li>for .. in 用于遍历对象属性，主要用于对象</li><li>除 symbol 以外的可枚举属性 也就是 Object.keys 能获取到的</li></ul><h2 id="可枚举属性是什么"><a href="#可枚举属性是什么" class="headerlink" title="可枚举属性是什么"></a>可枚举属性是什么</h2><p><a href="https://zhuanlan.zhihu.com/p/47291013">https://zhuanlan.zhihu.com/p/47291013</a></p><ul><li>for .. of 用于可迭代对象，像 Array、Map、Set、String、TypeArray</li><li>区别</li><li>for in 迭代的是可枚举的属性 也就是说如果是数组 这里得到的是索引而不是数组内的值，同时这里如果不做是否是自己的属性，会遍历包括继承得到的属性</li><li>for of 是遍历可迭代对象</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of</a></p><h2 id="可迭代对象是什么"><a href="#可迭代对象是什么" class="headerlink" title="可迭代对象是什么"></a>可迭代对象是什么</h2><p>现在比较模糊的理解就是像数组那样的数据结构</p><h1 id="2695-包装数组"><a href="#2695-包装数组" class="headerlink" title="2695.包装数组"></a>2695.包装数组</h1><p>这里涉及到 Js 的隐式类型转换，<br>对象进行运算的时候会先尝试用调用对象的 valueof 方法，获取到值然后再进行 Number()的转换处理<br>字符串操作的时候会尝试调用对象的 toString 方法</p><ul><li>隐式类型转换<br><a href="https://juejin.cn/post/7053055316899921934#heading-7">https://juejin.cn/post/7053055316899921934#heading-7</a></li></ul><p>数组的 toString 其实是覆盖 Object.toString()方法，实际上是调用的数组的 join()方法，如果没有 join 方法还是会调用 object 的</p><h1 id="2649-嵌套数组生成器"><a href="#2649-嵌套数组生成器" class="headerlink" title="2649. 嵌套数组生成器"></a>2649. 嵌套数组生成器</h1><h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><p><code>function*</code> 生成器函数</p><p>调用一个生成器函数 不会执行生成器函数里面的代码 会返回生成器的迭代器对象</p><p>也就是只有 next().value 这样才能拿到值</p><p>yield 也就是相当于生成器函数中的 retrun 只不过调用 next()就会往下走一个</p><p>yield* 将执行权交给另一个生成器 暂停该生成器</p><p>这里也就是相当于跳到另一个生成器里面去 用另一个生成器 yield 返回的值<br>等那个生成器的 yield 用完之后 再继续执行我们这个 把执行权拿回来</p><p>迭代器 next()中如果传参，是传给上一个 yiled 左边的值</p><p>如果用了 return 那就是正常的 return 返回 return 的值 然后 next().done &#x3D; true</p><p>这个生成器函数也叫迭代器函数 所以返回的是一个迭代器对象 就是名字这么叫而已</p><p>这个迭代器对象还能再展开：(没看)<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator</a></p><p>这个题目我还得到了一个 flag 的小技巧<br><code>arr.flat(Infinity)</code> 这样不管是几维数组都可以被扁平化拍成一个数组了<br>不过这个目前看来在某些 ts 版本下是会报类型错误的，大概就是 ts 不认识 Infinity，所以他会给你尝试用各种组合，导致这个报错</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ts</title>
    <link href="/2023/07/19/ts/"/>
    <url>/2023/07/19/ts/</url>
    
    <content type="html"><![CDATA[<h1 id="Ts-相关的知识点"><a href="#Ts-相关的知识点" class="headerlink" title="Ts 相关的知识点"></a>Ts 相关的知识点</h1><h2 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h2><p>这个其实是用来约束 key 和 value 怎么写的<br>那在我们平时开发中可能就直接写一个 interface 了，也是可以的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PageInfo</span> &#123;<br>    <span class="hljs-attr">title</span>:<span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Page</span> = <span class="hljs-string">&quot;home&quot;</span> | <span class="hljs-string">&quot;about&quot;</span> | <span class="hljs-string">&quot;contact&quot;</span><br><span class="hljs-keyword">const</span> nav = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">Page</span>, <span class="hljs-title class_">PageInfo</span>&gt; = &#123;<br>    <span class="hljs-attr">about</span>:&#123;<span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;aa&#x27;</span>&#125;<br>    <span class="hljs-attr">home</span>:&#123;<span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;aa&#x27;</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a href="https://www.jianshu.com/p/ff5ee22b2053">https://www.jianshu.com/p/ff5ee22b2053</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>offset</title>
    <link href="/2023/06/25/offset/"/>
    <url>/2023/06/25/offset/</url>
    
    <content type="html"><![CDATA[<h1 id="折线曲线偏移算法"><a href="#折线曲线偏移算法" class="headerlink" title="折线曲线偏移算法"></a>折线曲线偏移算法</h1><p>最近在研究折线曲线偏移算法 也就是外扩内缩算法</p><p>目前的参考论文有几下几篇</p><h2 id="An-offset-algorithm-for-polyline-curves"><a href="#An-offset-algorithm-for-polyline-curves" class="headerlink" title="An offset algorithm for polyline curves"></a>An offset algorithm for polyline curves</h2><ul><li><p>文档地址 <a href="https://sci-hub.se/10.1016/j.compind.2006.06.002">https://sci-hub.se/10.1016/j.compind.2006.06.002</a></p></li><li><p>代码实现 <a href="https://github.com/jbuckmccready/CavalierContours">https://github.com/jbuckmccready/CavalierContours</a></p></li></ul><h2 id="A-new-offset-algorithm-for-closed-2D-lines-with-Islands"><a href="#A-new-offset-algorithm-for-closed-2D-lines-with-Islands" class="headerlink" title="A new offset algorithm for closed 2D lines with Islands"></a>A new offset algorithm for closed 2D lines with Islands</h2><ul><li><p>文档地址 <a href="https://www.docin.com/p-1356454361.html">https://www.docin.com/p-1356454361.html</a></p></li><li><p>代码实现 <a href="https://blog.csdn.net/qq_41261251/article/details/114462696">https://blog.csdn.net/qq_41261251/article/details/114462696</a></p></li></ul><p>本篇论文提出了两种算法</p><ul><li>1、使用平分线的新偏移算法</li><li>2、一种无效偏移边缘处理算法</li></ul><h2 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h2><ul><li><p>1、判断顶点是凸点还是凹点，利用角平分线得到偏移角</p></li><li><p>2、偏移边的有效性，如果偏移边的方向与原始边的方向相反，则为无效边</p><ul><li>原始偏移曲线由偏移点按顺序连接起来，但是无效边不应该在其中<br>无效偏移边的处理算法有分两种情况<ul><li>不存在连续的无效偏移边<br>找到无效偏移边的前向边和后向边，前向边顺着偏移边的方向往后找到的第一个有效偏移边，后向边，偏移边的逆方向找到的第一个有效边<br>延长前向边和后向边得到交点，将这个交点作为前向边的起点，后向边的终点</li><li>存在连续的无效偏移边<br>还是找到这个前向边和后向边<br>找到无效偏移边的原始边，检查所选边是否与有效偏移边是否存在交点，存在交点，偏移该所选边，得到与前向边和后向边的交点，连接成一条新的线</li></ul></li></ul></li><li><p>3、无效环的处理<br>这里不是很明白 需要问一下<br>大致就是会定义一个路径方向，比如为顺时针，如果我们得到的环的方向为逆时针哪就是无效循环，无效的循环会被移除掉</p></li></ul><h2 id="2D-Curve-Offset-Algorithm-for-Pockets-with-Islands-using-a-Vertex-Offset"><a href="#2D-Curve-Offset-Algorithm-for-Pockets-with-Islands-using-a-Vertex-Offset" class="headerlink" title="2D Curve Offset Algorithm for Pockets with Islands using a Vertex Offset"></a>2D Curve Offset Algorithm for Pockets with Islands using a Vertex Offset</h2><ul><li>文档地址 <a href="https://sci-hub.se/10.1007/s12541-009-0037-9">https://sci-hub.se/10.1007/s12541-009-0037-9</a></li></ul><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>我这边处理的只是轮廊 轮廊包含折线和曲线</p><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>求线段交点 可使用叉积处理</p><p>求线段方向有效性 可以用点积处理（疑惑点，曲线怎么求有效方向, 曲线似乎一定是）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>力扣矩阵/几何类别的题</title>
    <link href="/2023/06/15/matrixLeetcode/"/>
    <url>/2023/06/15/matrixLeetcode/</url>
    
    <content type="html"><![CDATA[<h1 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a>463. 岛屿的周长</h1><p>首先要理解该题目<br>其次要理解二维数组<br>还要考虑二维数组的偏移索引<br>常规解法：迭代 如果是岛屿 我们就去找上下左右四个块 看看是不是水域或者边界，如果是水域或者边界，就+1，（边长）<br>dfs: 深度遍历 dfs 遍历 实际上就是递归 一直往后找 该题目也是找上下左右，从岛屿 找到其他的水域或者边界，周长就+1</p><h2 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566 重塑矩阵"></a>566 重塑矩阵</h2><p>这个题目有两个重要的知识点</p><ul><li>fill 的使用，这里我们使用 fill 来创建一个二维数组，fill 的参数如果不是基本数据类型，比如是数组，那么这里我们传递的是数组的引用地址，也就是改动一个，其他的数据也会一起变动，所以我们使用 map 解决</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> newArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<br><span class="hljs-comment">// [[0,0,0],[0,0,0]] 2行3列</span><br></code></pre></td></tr></table></figure><ul><li><p>二维数组的索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array1 = [<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>];<br><span class="hljs-comment">// 当前数组中所有的数据长度 行*列</span><br><span class="hljs-keyword">const</span> data = array1.<span class="hljs-property">length</span> * array1[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br><span class="hljs-comment">// 第x个元素的值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; data; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">const</span> x = i;<br><span class="hljs-keyword">const</span> col = array1[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br><span class="hljs-keyword">let</span> val = array[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(x / col)][x % col];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="812-最大三角形的面积"><a href="#812-最大三角形的面积" class="headerlink" title="812 最大三角形的面积"></a>812 最大三角形的面积</h2><h2 id="向量的叉乘和点乘"><a href="#向量的叉乘和点乘" class="headerlink" title="向量的叉乘和点乘"></a>向量的叉乘和点乘</h2><h3 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h3><p>两个向量叉乘会得到一个新的向量，该新向量的方向垂直于向量 1 和向量 2，长度为向量 1 和向量二张成空间的平行四边形的面积<br>叉乘得到的是一个向量，向量是有方向的，所以 A 叉乘 B 不满足交换律<br>A 叉乘 B 得到的向量的方向是满足右手定则</p><p>右手定则 右手指向第一个向量的方向 沿着第二个向量的方向弯曲手指，大拇指所指的方向就是叉乘的方向</p><h3 id="点乘-点积"><a href="#点乘-点积" class="headerlink" title="点乘 点积"></a>点乘 点积</h3><p>A 点乘 B &#x3D; |A| _ |B| _ cos 角度<br>这里我们从几何角度来看也就是 B 在 A 或者是 A 在 B 上的投影再与另一个向量相乘<br>点 点积得到是是一个数</p><h2 id="向量的行列式"><a href="#向量的行列式" class="headerlink" title="向量的行列式"></a>向量的行列式</h2><p>向量张成空间的面积<br>向量之间具有可加性<br><a href="https://www.bilibili.com/video/BV1MY411J72b/?spm_id_from=333.337.search-card.all.click&vd_source=cce0370852a05575ac787ef99b1d8903">https://www.bilibili.com/video/BV1MY411J72b/?spm_id_from=333.337.search-card.all.click&amp;vd_source=cce0370852a05575ac787ef99b1d8903</a></p><p>所以本题我们美美利用行列式的公式来处理,得到的是平行四边形的面积，除 2 得到的就是三角形</p><p>这里在二维空间中存在存在三个向量，行列式最后一项为 1<br>也就是 |x1 y1 1|<br>|x2 y2 1|<br>|x3 y3 1|<br>我们可以用对角线相乘来得到结果<br><code>const res = x1 * y2 + x2 * y3 + x3*y1 - x1 *y3 - x2 *y1 -x3*y2</code><br>遍历这个三个点就能得到最后的答案 这里还有一个坑 面积一定要是正整数</p></li></ul><h2 id="矩形重叠"><a href="#矩形重叠" class="headerlink" title="矩形重叠"></a>矩形重叠</h2><p>这个题目我们去考虑边界，会发现是一道很简单的题<br>从这个简单题中我们可以找到一个新的名词 交并比</p><h3 id="什么是交并比-怎么理解"><a href="#什么是交并比-怎么理解" class="headerlink" title="什么是交并比 怎么理解"></a>什么是交并比 怎么理解</h3><p>A，B 分别为两个集合<br>IOU &#x3D; A 与 B 的交集&#x2F;A 与 B 的并集<br>IOU 的交集 &#x3D; 0 完全没有重叠<br>IOU 的交集 &#x3D; 1 完全重叠<br><a href="https://paddlepedia.readthedocs.io/en/latest/tutorials/computer_vision/object_detection/IOU.html">https://paddlepedia.readthedocs.io/en/latest/tutorials/computer_vision/object_detection/IOU.html</a></p><p>这里我们假设如果两个矩形存在交点<br>那么左上的 Xa 点 &#x3D; Math.max(xm1,xn1)<br>右下的 Xb 点 &#x3D; Math.min(xm2,xn2)</p><p>那么存在交点,同理 y 轴也一样<br>Xb - Xa &gt; 0</p><h2 id="883-三维形体投影面积"><a href="#883-三维形体投影面积" class="headerlink" title="883. 三维形体投影面积"></a>883. 三维形体投影面积</h2><p>此题用的暴力解法，没有技巧，只有暴力<br>如果不理解行和列可以把二维数组写为矩阵就很清晰<br>grid.length 为行<br>grid[0].length 为列<br>遍历得到 xy 区域的面积 grid[i][j] !&#x3D;&#x3D; 0<br>遍历得到 xz 区域的面积 这里也就是求每列中的最大值<br>遍历得到 yz 区域的面积 这里求每行的最大值 先遍历列再遍历行</p><h1 id="892-三维形体的表面积"><a href="#892-三维形体的表面积" class="headerlink" title="892. 三维形体的表面积"></a>892. 三维形体的表面积</h1><p>这个题我纯暴力解法，找到当前这个块的前一行前一列的覆盖面，有就剪掉<br>这里不要忽略叠加的上下覆盖面积的就行</p><h1 id="1030-距离顺序排列矩阵单元格"><a href="#1030-距离顺序排列矩阵单元格" class="headerlink" title="1030. 距离顺序排列矩阵单元格"></a>1030. 距离顺序排列矩阵单元格</h1><p>这里我用的直接排序法，遍历求索引，计算距离然后使用 sort</p><h2 id="array-sort-的时间复杂度为什么是-O（n-log-n）"><a href="#array-sort-的时间复杂度为什么是-O（n-log-n）" class="headerlink" title="array.sort 的时间复杂度为什么是 O（n log n）"></a>array.sort 的时间复杂度为什么是 O（n log n）</h2><p><a href="https://segmentfault.com/a/1190000010648740/">https://segmentfault.com/a/1190000010648740\</a><br>emm..总之每个浏览器的算法实现不太一样</p><h2 id="哈曼顿距离是什么"><a href="#哈曼顿距离是什么" class="headerlink" title="哈曼顿距离是什么"></a>哈曼顿距离是什么</h2><p>也叫做出租车距离，标明两个点在标准坐标系上的<code>绝对轴距总和</code><br>也就是两个点之间的距离，用 x 轴和 y 轴计算的距离来确定<br><code>d(i,j)=|xi - xj| + |yi - yj|</code></p><h2 id="桶排序是什么"><a href="#桶排序是什么" class="headerlink" title="桶排序是什么"></a>桶排序是什么</h2><p>算法相关阅读<br><a href="http://data.biancheng.net/array_list/">http://data.biancheng.net/array_list/</a></p><p><a href="https://zhuanlan.zhihu.com/p/125737294">https://zhuanlan.zhihu.com/p/125737294</a><br>桶排序感觉就是把一个大数据，按照一定的范围划分，处理为一些个小数据放到桶中（小桶），然后在小桶中（非空桶）处理排序好再合并成大数据</p><p>可以做桶排序处理</p><h1 id="1232-缀点成线"><a href="#1232-缀点成线" class="headerlink" title="1232. 缀点成线"></a>1232. 缀点成线</h1><p>已知 A(x1,y1)、B(x2,y2)两点<br>向量 AB &#x3D; (x2 - x1, y2 -y1); B - A<br>这个题目是至少有一条线的 两个向量的行列式为 0 则为共线<br>这里我们只要判断行列式 行列式为 0 那就<br><a href="https://blog.csdn.net/qq_44691917/article/details/104686146">https://blog.csdn.net/qq_44691917/article/details/104686146</a><br><a href="https://zhidao.baidu.com/question/1950383038479802228.html">https://zhidao.baidu.com/question/1950383038479802228.html</a></p><p>这里关于向量的积其实是有两种的</p><ul><li>数量积 点积<br>A B &#x3D; x1<em>x2 + y1</em>y2<br>几何意义：|a|*|b|*cosθ b 在 a 或者 a 在 b 方向上的投影<br>这里就可以用来判断两个向量之间的夹角大小<br>点积描述的是 A，B 的共线程度</li><li>向量积 叉积 描述的是垂直程度</li></ul><h1 id="1266-访问所有点的最小时间"><a href="#1266-访问所有点的最小时间" class="headerlink" title="1266. 访问所有点的最小时间"></a>1266. 访问所有点的最小时间</h1><h2 id="欧式距离、曼哈顿距离、切比雪夫距离相关解释"><a href="#欧式距离、曼哈顿距离、切比雪夫距离相关解释" class="headerlink" title="欧式距离、曼哈顿距离、切比雪夫距离相关解释"></a>欧式距离、曼哈顿距离、切比雪夫距离相关解释</h2><p><a href="https://cloud.tencent.com/developer/article/1524568">https://cloud.tencent.com/developer/article/1524568</a></p><p>在这个题目中不要被这个看着很可怕的题目吓到了，这里也就是求最短移动距离，这里前后左右斜着走都是一样的为 1，显然走斜边会更快<br>所以这里我们使用切比雪夫距离 这个来做<br>假设点为<code>a:x1,y1</code>,<code>b:x2,y2</code><br>那么 a 移动到 b 的最短距离只和为<br><code>dx = |x1 - x2|</code><br><code>dy = |y1 - y2|</code><br><code>max(dx,dy)</code></p><h1 id="223-矩形面积"><a href="#223-矩形面积" class="headerlink" title="223. 矩形面积"></a>223. 矩形面积</h1><p>这个和之前矩形重叠那个差不多，重温一遍发现自己并没有弄明白<br>这个最巧妙的位置在于 将矩形变换为 x 轴上的投影和 y 轴上的投影</p><p>画图之后我们能够很直观的感受到重叠是怎么样的 不重叠是怎么样的</p><p>这里需要注意的是 对于两个矩形的位置关系 谁在前谁在后其实并不知道</p><p>所以我们使用 <code>Math.min</code> <code>Math.max</code> 来确定</p><p>以 x 轴为例 首先是对于一个矩形 从题意描述的位置关系 给的坐标 一个在左下角，一个在右上角一定是 <code>x1 &lt; x2</code> 的</p><p>所以如果<code>Math.min(ax2,bx2) &gt; Math.max(ax1,bx1)</code>这种情况下 一定是重叠，y 轴同理</p><p>如果两个矩形存在重叠区域，我们依然可以画个图</p><p>那么它重叠区域 x 的坐标 <code>Math.max(ax1,bx1)、 Math.min(ax2,bx2)</code>，y 值同理，画图非常直观</p><h1 id="593-有效的正方形"><a href="#593-有效的正方形" class="headerlink" title="593 有效的正方形"></a>593 有效的正方形</h1><p>本题有三种方法<br>1、先试用巧妙的旋转法</p><ul><li>找到中点坐标，移动到原点，记录所有点的坐标，旋转后也应该在该数组内</li><li>旋转 90 度后所有的点都还在<h3 id="2D-平面下的旋转"><a href="#2D-平面下的旋转" class="headerlink" title="2D 平面下的旋转"></a>2D 平面下的旋转</h3><a href="https://blog.csdn.net/scut_salmon/article/details/100406459">https://blog.csdn.net/scut_salmon/article/details/100406459</a></li></ul><p>2、找三个顶点，判断是否是直角三角形</p><p>3、正方形判断定理</p><ul><li>斜边的中点相同，则说明两条斜边组成的四边形为平行四边形</li><li>两条斜边的长度相同，说明为矩形</li><li>两条斜边相互垂直，为正方形<br>这题看太久已经疲了 只用了解法 1 来处理，如果有需要后面再看看</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode</title>
    <link href="/2023/05/24/leetcode/"/>
    <url>/2023/05/24/leetcode/</url>
    
    <content type="html"><![CDATA[<h2 id="大-O-表示法"><a href="#大-O-表示法" class="headerlink" title="大 O 表示法"></a>大 O 表示法</h2><p>对算法的效率进行衡量</p><p>企业规模概述：小型&#x2F;中型&#x2F;大型</p><p>在不说明具体员工数量或者占地面积的情况下，我们可以通过大概这样（上述）的概率来描述企业的规模</p><p>在计算机中也可以通过类似的快捷方式来描述计算机算法的效率 也就是大 O 表示法</p><p>首先要知道 在数据量不同的情况下，算法的效率也是会变的</p><p>算法的效率：</p><p><strong>算法的速度</strong> 与 <strong>数据量变化</strong> 之间的关系</p><p>其实也就是 我要找查找多少次才能找到我想要的数据</p><p>遍历 n 次找到 那就是 O(n)<br>使用二分查找 那就是 O(log(n))<br><a href="https://juejin.cn/post/6844903481191432206">https://juejin.cn/post/6844903481191432206</a></p><h2 id="常见的大-O-表示函数"><a href="#常见的大-O-表示函数" class="headerlink" title="常见的大 O 表示函数"></a>常见的大 O 表示函数</h2><p>O 可以理解为一个函数</p><p>O(1) 常数的<br>O(log(n)) 对数的<br>O(n) 线性增长<br>O(nlog(n)) 线性和对数成绩<br>O(n^2) 平方<br>O(2^n) 指数</p><p>用 O(1)代替所有的常量<br>在修改后的运行次数函数中，只保留最高阶<br>如果最高存在且不为 1，则去除这项相乘的常数 2n^2 + n ）O(n^2)</p><h2 id="力扣题目记录"><a href="#力扣题目记录" class="headerlink" title="力扣题目记录"></a>力扣题目记录</h2><p>最近开始刷算法题了，太菜啦，虽然焦虑，但是还是要一步步提升自己，此处记录一下相关题目</p><h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><p>核心思想是使用两个指针，分别指向不同的元素</p><ul><li><p>快慢指针</p></li><li><p>还有 对撞指针，从数组两头向中遍历</p></li><li><p>还有 滑动窗口，遍历相同的数组但是不会相交</p></li></ul><h2 id="26-删除数组中的重复项"><a href="#26-删除数组中的重复项" class="headerlink" title="26.删除数组中的重复项"></a>26.删除数组中的重复项</h2><ul><li>这个用的快慢指针</li></ul><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><ul><li>这个用的快慢指针</li><li>这个还可以使用对撞指针，因为不需要管排序，就是只要数组中的数据等于当前条件给的值，那我们就把它替换成我们没有用过的值</li><li>这个最简单的还是 splice(移除或者替换) 一下，就地改变数组，返回删除的元素</li><li>toSpliced 和 splice 一样，但是是返回一个新数组</li><li>这里容易根 slice(片段化) 搞混， slice 是提取某一部分，返回一个新数据（数组&#x2F;字符串），包含 start 不包含 end，参数为负数则反着取，end 小于 start 就不返回，不写或者超出数据长度，最长就是数据长度</li></ul><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h2><ul><li>二分查找 前提 是一个有序序列，从中间找最重要的步骤就是指针 mid &#x3D; left + ((right - left)&gt;&gt;1)</li></ul><h2 id="27-移除元素-1"><a href="#27-移除元素-1" class="headerlink" title="27 移除元素"></a>27 移除元素</h2><p>String 的相关操作<br>split 切割为数组 什么都不传 数组没有这个方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br>str.<span class="hljs-title function_">split</span>(); <span class="hljs-comment">// [&#x27;Hello World&#x27;]</span><br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// [&#x27;H&#x27;,&#x27;e&#x27;...]</span><br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-comment">// [&#x27;Hello&#x27;, &#x27;World&#x27;]</span><br></code></pre></td></tr></table></figure><p>slice 片段化 也就是提取数据中的一部分 负数就是拿数组总长度去剪<br>Array 的操作<br>at 传参整数 找到数组中的索引 为负数则从最后一个倒着找 -1 就是最后一个</p><h2 id="66-加一"><a href="#66-加一" class="headerlink" title="66 加一"></a>66 加一</h2><p>方法一：转换为字符串再转换为数字，这个要考虑的是字符串转数字后会超出范围的情况，题目是整数，所以可以用 BigInt 来转换<br>方法二：就是纯数组操作了，需要注意的就是进位问题</p><h2 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67 二进制求和"></a>67 二进制求和</h2><p>js 中的最大安全是 2^53 - 1<br>超过这个范围的整数运算结果就会不准确<br><code>2**53 === 2**53 + 1 // true</code><br>字符串转数字这里一定要考虑转数字之后的范围超出问题<br>js 已经封装的十进制与二进制的转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 二进制转十进制</span><br><span class="hljs-comment">// parseInt这个是指 值是多少，我该以什么进制来处理当前这个数字，然后再转回十进制</span><br><span class="hljs-comment">// 也就是将100看作是二进制数，再转换为十进制</span><br> <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;100&#x27;</span>,<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 十进制转二进制 toString 将十进制转换为对应进制的字符串类型</span><br>‘<span class="hljs-number">10</span>’.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>所以使用了 BigInt 处理，<br>这里还需要知道的是一个前缀，0B，0b 是二进制，0 是八进制，0X，0x 是十六进制<br>这个目前为只用了这个方式处理</p><h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69 x 的平方根"></a>69 x 的平方根</h2><ul><li>二分查找<br>这里有个需要注意的地方 mid 的计算<br>超过最大或者最小范围就会溢出<br>这里我们需要考虑溢出情况 所以不使用 (right + left) &gt;&gt; 1<br>使用 left + ((right - left) &gt;&gt; 1)</li></ul><p>考虑溢出 所以使用 x&#x2F;mid &gt; mid 这样处理<br>解法二：牛顿迭代 这个没有特别仔细看</p><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a>70 爬楼梯</h2><p>解法一：<br>动态规划 Dynamic Programming<br>也就是把一个大问题，变成很多子问题，然后解决子问题，最终得到大问题的答案<br>这里我们首先分析题目 找找规律 然后会发现 d[i] &#x3D; d[i-1]+d[i-2]<br>动态规划最重要的就是记忆化搜索 这里是使用数组记录了数据, 还可以不用数组，直接挪动指针那样处理，但是还是使用数组更清晰，还有就是边界判断非常重要</p><p>这里还可以递归，本质上能够使用动态规划的都可以使用递归暴力推断，这里要注意的还是要记录已递归的数据，不然会超时</p><p>解法二：<br>数学规律<br>斐波那契数列 公式法<br>Math.sqrt 开方<br>Math.pow(x, y) x 的 y 次幂</p><h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83 删除排序链表中的重复元素"></a>83 删除排序链表中的重复元素</h2><p>指针题，这里要注意的是链表的表头是不能跑的，所以需要再创建一个指针来指向相同的引用地址，这个指针是一直向后遍历的（向后走），遍历过程中根据条件去改变链表的数据，返回这个链表实际上还是返回这个链表的表头，链表由表头来进行表示</p><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88 合并两个有序数组"></a>88 合并两个有序数组</h2><p>解法一：直接合并数组再进行排序<br>这里注意 splice 的使用 num.splice(start, delcount, replaceData1,replaceDate2)</p><p>解法二：指针 这里其实倾向是考指针<br>指针相关的方法，我觉得最主要的考虑还是一个边界问题；</p><ul><li>双指针 从头开始，把两个数组当作两个队列，创建一个新的数据，长度 m+n,依次往里面添加元素</li><li>逆向双指针 从末尾开始，该题目的前提是 num1 的长度是大于 m+nssm+nss, 这个感觉思维上不是那么好理解，再写可能还是会用正向的双指针,其实也就是正着来处理，你可能需要往原数组中添加元素，反着来不会去破坏数组结构，是一样的；</li></ul><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94 二叉树的中序遍历"></a>94 二叉树的中序遍历</h2><p>首先要知道的是二叉树的遍历有哪几种<br>前序遍历：中 左 右<br>中序遍历：左 中 右<br>后序遍历：左 右 中</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>当想要使用递归的时候，我们应该考虑什么</p><ul><li>递归的参数，递归的返回值</li><li>考虑递归终止的条件，如果不这样处理很容易出现栈溢出的情况</li><li>考虑递归我们处理的信息是什么</li></ul><h4 id="递归的特点"><a href="#递归的特点" class="headerlink" title="递归的特点"></a>递归的特点</h4><ul><li>函数要间接或者直接的调用自身</li><li>要设置终止条件，我们每一个调用这个函数都是为了更接近这个终止条件</li><li>不满足这个终止条件，我们则继续调用这个函数</li></ul><h3 id="栈-先进后出"><a href="#栈-先进后出" class="headerlink" title="栈 先进后出"></a>栈 先进后出</h3><p>这个题目的考点其实是栈 用栈 迭代</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>迭代和递归都是循环，在循环量比较大的情况下，迭代的效率比递归更好</p><p>迭代与普通循环的区别</p><p>迭代中参与运算的变量和保存结果的变量是同一个变量，当前保存的结果是下次迭代的初始值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">1</span>; <span class="hljs-comment">// 参与运算的变量</span><br><span class="hljs-keyword">let</span> i = <span class="hljs-number">100</span>; <span class="hljs-comment">// 参与运算的变量</span><br><span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>   sum ++; <span class="hljs-comment">// 保存结果的变量</span><br>   i --;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归是函数调用自身函数<br>迭代是函数内某段代码实现循环</p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>按规则访问每一项目</p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>一切重复行为</p><h4 id="题外-产品中的迭代"><a href="#题外-产品中的迭代" class="headerlink" title="题外 产品中的迭代"></a>题外 产品中的迭代</h4><p>传统开发，纯线性的 开发 -&gt; 测试上线<br>迭代是把一个大的目标 分为一些小目标，来进行单独的设计-&gt;开发-&gt;测试，进行多次这周周期性的操作完成一个软件产品的最终发布，迭代式开发更灵活，更能适应突然的需求变更之类的</p><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144 二叉树的前序遍历"></a>144 二叉树的前序遍历</h2><h2 id="145-二叉树的后续遍历"><a href="#145-二叉树的后续遍历" class="headerlink" title="145 二叉树的后续遍历"></a>145 二叉树的后续遍历</h2><p>这三个其实是一样的，我这边选择美美用迭代法处理<br>前序：遍历找到最后一个左子节点，在这个过程中就把根节点 push 进结果，将左节点依次入栈里面，然后弹出，每弹出一个，就把指针指向右子节点，重复再去找左子节点，套两个 while<br>中序：和上面一样，只不过 push 结果的位置放在了左子节点弹出的时候<br>后序：这里和前序放过来想，前序是中左右，我们只要改为中右左，再进行 reverse 就能拿到正确的数据，所有这里我们把右节点依次入栈，再把指针指向左节点，重复去找右节点</p><p>总之 没有那么复杂，把指针美美用起来</p><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a>100. 相同的树</h2><p>这个题一拿到，唯唯诺诺的我立刻重拳处理，这不是刚学的树的遍历吗，还热乎的，于是我马上写了一个前序遍历，打算比较一下两颗树前序遍历的结果，点击提交，测试结果对我重拳出击<br>这里对树节点的遍历是忽略了空节点的，所以拿到的结果就不准确了<br>比如两棵树，[1,2],[1,null,2]</p><p>首先了解两个基本概念：</p><ul><li>广度优先算法</li><li>深度优先算法</li><li><a href="https://cloud.tencent.com/developer/article/1930785">https://cloud.tencent.com/developer/article/1930785</a></li></ul><p>我们直接拿一个树结构来当作参照物<br>广度优先算法 就是按照每一层一层的节点来进行遍历<br>深度优先算法 就是一条路一直找到最下面的所有的都找完了又会到第一个根节点，再去找另外的</p><p>这里是直接采用深度优先的处理，直接递归去找到左&#x2F;右节点值然后进行对比</p><h2 id="101-对称的二叉树"><a href="#101-对称的二叉树" class="headerlink" title="101. 对称的二叉树"></a>101. 对称的二叉树</h2><ul><li><p>递归 将树拆开来看 对比左右，右左节点<br>递归这里用了指针思想，考虑有两个指针 p 和 q，他们的起点相同，走向的方位不同<br>p 左走 q 向右 p 右走 q 左走 对比值是否相等 相等继续往下找 不想等就直接 return false</p></li><li><p>迭代</p><ul><li>引用队列（栈）是把递归程序改写为迭代程度的常用方法<br>其实感觉差不多 该用队列也就是注意什么时候进栈 什么时候出栈 出栈之后要做什么<br>那在本题中 进栈 也就是我们把节点加进去（除去根节点&#x2F;左右节点都需要入栈 进行两两比较）<br>出栈也就是栈内存在内容 就需要继续进行 while 循环 此处我们是两两入栈进行比较 所以要两两出栈<br>出栈之后我们要进行值的比较 特殊情况是都为 null 的时候此时循环还需要继续执行 其中一方为 null 或者值不相等 就 return false<br>出栈之后 继续把剩下的节点继续进行进栈操作</li></ul></li></ul><h2 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a>28. 找出字符串中第一个匹配项的下标</h2><ul><li>js 偷懒法 indexOf 一把梭</li><li>暴力遍历法 找到小的那个数据 然后双重遍历 做匹配</li><li>kmp 算法 还没看</li><li><a href="https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></li></ul><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p>这里首先需要了解两个概念</p><ul><li>树的高度</li><li>树的深度</li><li><img src="/2023-08-09-00-03-57.png"></li></ul><p>一棵树的最大深度 &#x3D; 根节点的高度+左右子树中最大的深度<br>那这个问题就变成了求深度<br>有两种方法解决这个问题</p><ul><li><p>递归法<br>递归需要注意什么 需要注意递归的结束条件<br>脑子转不动系列：<br><a href="https://www.bilibili.com/video/BV1UD4y1Y769/?vd_source=cce0370852a05575ac787ef99b1d8903">https://www.bilibili.com/video/BV1UD4y1Y769/?vd_source=cce0370852a05575ac787ef99b1d8903</a></p></li><li><p>bfs 广度优先遍历<br>&lt; 这里再介绍一下广度优先遍历和深度优先遍历 因为我已经忘记了</p><ul><li>广度优先遍历 一层层去找</li><li>深度有限遍历 一条路走到底</li></ul></li></ul><h1 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a>581. 最短无序连续子数组</h1><p>最近比较懈怠 这个是看 b 站左程云老师讲的<br>这个其实没什么特别的 一道双指针题<br>主要就是要想清楚 什么时候指针该动<br>以及 两个方向去遍历</p><ul><li><p>从左到右去遍历 我们找最大值 如果下一个值比当前的最大值小 指针移动</p></li><li><p>从右到左去遍历 我们找最小值 如果下个值比当前的最小值大 指针移动<br>特殊情况 注意数组为 1 的情况 不需要排序<br>其他情况 higt &gt; low ? higt - low + 1 : 0</p><p><a href="https://www.bilibili.com/video/BV1CG411Z7zH/?spm_id_from=333.999.0.0&vd_source=cce0370852a05575ac787ef99b1d8903">https://www.bilibili.com/video/BV1CG411Z7zH/?spm_id_from=333.999.0.0&amp;vd_source=cce0370852a05575ac787ef99b1d8903</a></p></li></ul><h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h1><p>排序类的题 需要看一下摩尔投票法</p><h2 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h2><p>也叫多数投票法<br>这个算法很有意思</p><p>核心我们看作为是对抗消耗，也就是数组中不同的数据进行相互抵消</p><p>通俗来说可以看做是选举，根据票数来选择候选人</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p><strong>这个多数元素在数组中重复出现，且占据了数组元素的一半以上</strong></p><p>首先需要知道这个算法的应用场景，这个算法实际上是用来求这个多数元素的</p><p>这里其实也就是众数</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>这里其实是分两步</p><ul><li>找出多数元素</li><li>进行验证</li></ul><h2 id="补充抽屉原理"><a href="#补充抽屉原理" class="headerlink" title="补充抽屉原理"></a>补充抽屉原理</h2><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>类型化数据</title>
    <link href="/2023/04/28/ArrayBuffer/"/>
    <url>/2023/04/28/ArrayBuffer/</url>
    
    <content type="html"><![CDATA[<p>最近重新开始写引擎部分代码 感觉什么也不会 重新看了这部分有了新的理解</p><h2 id="类型化数据"><a href="#类型化数据" class="headerlink" title="类型化数据"></a>类型化数据</h2><p>js 用来为开发者提供一个操作二进制数的一个借口</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>也就是一个提前预设了大小的内存块<br>有两种类型的缓冲</p><ul><li>&lt;1&gt; ArrayBuffer 可以当作是单向的一个 buffer 因为转移后就会失效 那么同一时刻，它只会在某一个执行上下文中，多线程同时访问一个内存块的时候，要使用 atomics</li><li>&lt;2&gt; sharedAarryBuffer 其实可以看作是一个全局缓冲 所以不存在转移<br>支持以下操作</li><li>分配 <code>new ArrayBuffer()</code> 初始值为 0</li><li>复制 <code>slice()</code></li><li>转移 <code>transfer()</code> <code>transferToFixed()</code> 可以已传参为例子 A 函数的 Abuffer 想在 B 函数中（不同的执行上下文）给另一个 Bbuffer 使用，转移后 Abuffer 就不能用了，</li><li>调整大小 resize() 可以调整内存块的大小 但是不能超过我们提前预设的内存的最大字节长度</li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图的类型包括，视图也就是对 arrayBuffer 的读写操作</p><ul><li>数据类型</li><li>起始偏移量</li><li>元素数量</li></ul><p>目前主要有两种视图</p><h4 id="类型化数组视图"><a href="#类型化数组视图" class="headerlink" title="类型化数组视图"></a>类型化数组视图</h4><blockquote><p>也就是 TypedArray</p></blockquote><h5 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h5><p>类数组对象 TypedArray 中元素值的类型都相同</p><p>共有以下十种具体的 TypedArray</p><ul><li>Int8Array</li><li>Uint8Array</li><li>Uint8ClampedArray 8 位无符号<strong>整型</strong>固定数组 如果你指定一个在 [0,255] 区间外的值，它将被替换为 0 或 255</li><li>Int16Array</li><li>Uint16Array</li><li>Int32Array</li><li>Uint32Array</li><li>Float32Array</li><li>Float64Array</li><li>BigInt64Array</li><li>BigUint64Array</li></ul><blockquote><p>前置知识</p></blockquote><ul><li>有符号数 可以区分正负值 例如 -128 - 127 最高位表示正负号，为 1 时，该值为负数</li><li>无符号数 只有正值 0-255<br>一个字节 &#x3D; 8bit</li><li><a href="https://www.cnblogs.com/lazycoding/archive/2011/03/21/unsigned-signed.html">https://www.cnblogs.com/lazycoding/archive/2011/03/21/unsigned-signed.html</a></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 分配一个16个字节的内存 创建一个缓冲</span><br><span class="hljs-keyword">let</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>视图使用上分为以下几种情况</p><h3 id="1、使用-arrayBuffer"><a href="#1、使用-arrayBuffer" class="headerlink" title="1、使用 arrayBuffer"></a>1、使用 arrayBuffer</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 将buffer视为一个32位的整数序列 打印可以看到转换为了四个为0的整数</span><br><span class="hljs-comment">// 这里可以这么理解 我现在有一个16字节的缓冲，如果我用一个Unit32Array去构建，表示的就是4个字节 那么我能够得到4个数据</span><br><span class="hljs-keyword">let</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(buffer);<br><span class="hljs-comment">// 设置偏移字节为4 也就是从第四个字节开始读 也就是跳过第一个数据，读取两个数据长度，这里注意Unit32Array表示的就是4个字节一个数据</span><br><span class="hljs-comment">// 这里的偏移一定要和约束的字节长度一致 比如当前uint32Array 是以每四个字节作为一个数</span><br><span class="hljs-keyword">let</span> view2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(buffer, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="2、使用数组"><a href="#2、使用数组" class="headerlink" title="2、使用数组"></a>2、使用数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-comment">// 这里是已经转换成为视图的数据 所以我们能直接看到塞了四个整数</span><br><span class="hljs-comment">// 这种情况下 存在的字节数量是4*4 这里就不存在什么偏移了 因为不是buffer</span><br><span class="hljs-comment">// 通过view[0]之类的数组操作可以直接拿到数组数据</span><br></code></pre></td></tr></table></figure><h3 id="3、使用另一个视图"><a href="#3、使用另一个视图" class="headerlink" title="3、使用另一个视图"></a>3、使用另一个视图</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>]);<br><span class="hljs-keyword">let</span> view2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(view);<br><span class="hljs-comment">// 相当于是一个复制操作 但是这种不同字节长度的需要注意 比如Uint8Array的字节范围是0-255 这个1000就塞不进去 会转换成别的，这里转换为的是232 原因如下</span><br></code></pre></td></tr></table></figure><p>转化的问题 存在一个越界行为的约束</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">1000</span>;<br><span class="hljs-comment">// 转化为2进制</span><br><span class="hljs-keyword">let</span> num2 = num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 1111101000</span><br><span class="hljs-comment">// uint8最多只能保存8位的二进制数所以范围为0-255</span><br><span class="hljs-comment">// 所以只保留最后8位 其他部分切掉</span><br><span class="hljs-comment">// 切掉后重新转换为转换为2进制数 232</span><br><span class="hljs-built_in">parseInt</span>(num2, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="4、直接使用数字"><a href="#4、直接使用数字" class="headerlink" title="4、直接使用数字"></a>4、直接使用数字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint16Array</span>(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// 相当于就是创建了4个为0的整数数据 字节长度是 4*2 数据长度是4</span><br></code></pre></td></tr></table></figure><h3 id="5、不带任何参数"><a href="#5、不带任何参数" class="headerlink" title="5、不带任何参数"></a>5、不带任何参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>();<br><span class="hljs-comment">// 创建一个长度 字节数都为0的类型化数组</span><br></code></pre></td></tr></table></figure><p>虽然我们可以直接创建 TypedArray，没有自己去创建 ArrayBuffer，但是视图层是离不开底层 ArrayBuffer 的，在没提供 ArrayBuffer 的场景下，都会自动创建</p><p>可以通过<code>arr.buffer</code> 查看引用的是哪个<br>可以通过<code>arr.byteLength</code> 查看引用 buffer 的长度</p><p>视图之间可以进行相互转化<br>这是什么意思呢 我们可以知道视图是服务于 ArrayBuffer,只要我们拿到一个 buffer，可以用各种不同的方式去查看她</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr8 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-comment">// [0,1,2,3]</span><br><span class="hljs-keyword">let</span> arr16 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint16Array</span>(arr8.<span class="hljs-property">buffer</span>);<br><span class="hljs-comment">// [256, 770]</span><br></code></pre></td></tr></table></figure><p><strong>至于怎么转化的现在还不知道</strong></p><p>TypedArray 具有常规的数组方法</p><p>可以进行遍历 map slice(切分 返回一个新的数组，前面的索引包含，后面的索引不包含) find ruduce 之类的</p><p>没有的</p><ul><li>splice 没有删除和替换 因为缓冲区是固定的，我们能做的只有分配</li><li>concat 没有聚合</li></ul><p>简单来说类数组的大小是固定的 改变内存大小这些方法是没有的</p><p>新增的</p><ul><li><p>arr.set(forArr, [offset]) offset 的处理不太明白</p><p>这里 offset 可以理解为下标索引 并且要考虑长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr16 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint16Array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1001</span>, <span class="hljs-number">1002</span>]);<br><span class="hljs-keyword">let</span> arr18 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint16Array</span>([<span class="hljs-number">2</span>, <span class="hljs-number">2000</span>]);<br>arr16.<span class="hljs-title function_">set</span>(arr18, [<span class="hljs-number">1</span>]); <span class="hljs-comment">// 从索引1的位置开始复制</span><br><span class="hljs-comment">// [1,2,200,1002]</span><br><span class="hljs-comment">// 设置一个不同视图的会进行转换 转换还是不知道为什么</span><br></code></pre></td></tr></table></figure></li><li><p>arr.subarray([begin, end]) begin 包括 end 不包括<br>?? 这个测试之后有些不对 传递不同的参数并没有什么变化</p></li></ul><h2 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h2><p>看上去是能够轻松获取到 buffer 中的值</p><h3 id="DataView-1"><a href="#DataView-1" class="headerlink" title="DataView"></a>DataView</h3><blockquote><p>更底层</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">16</span>);<br><span class="hljs-keyword">const</span> int32View = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int32Array</span>(buffer);<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><h3 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h3><p><a href="https://juejin.cn/post/6844903682283143181">https://juejin.cn/post/6844903682283143181</a></p><h3 id="JavaScript-类型化数组"><a href="#JavaScript-类型化数组" class="headerlink" title="JavaScript 类型化数组"></a>JavaScript 类型化数组</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Typed_arrays">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Typed_arrays</a></p><h3 id="webgpu-案例"><a href="#webgpu-案例" class="headerlink" title="webgpu 案例"></a>webgpu 案例</h3><p><a href="http://www.webgl3d.cn/pages/359922/">http://www.webgl3d.cn/pages/359922/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm</title>
    <link href="/2023/04/25/algorithm/"/>
    <url>/2023/04/25/algorithm/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>数据结构就是在计算机中存储和组织数据的方式</p><p>计算机中的数据量非常庞大，如何以高效的方式组织和存储？</p><p>方式 跟数据量有关</p><p>例如图书： 卧室 书店 图书馆<br>书 放哪里<br>书 怎么取</p><p>1、随便放<br>2、按字母<br>3、先按类别 再按字母顺序 二分查找？效率非常高的查找方式 查找中间 再等分等分</p><p>解决问题方法的效率，跟数据的组织方法有关</p><p>以什么样的方式来存储和组织我们的数据才能在使用数据的时候更方便，这就是数据结构需要考虑的问题</p><p>常见的的数据结构</p><p>不同的数据结构 不同的操作 性能都是不同的 根据具体的需求选择</p><p><strong>了解真相 你才能获得真正的自由</strong></p><ul><li>数组</li><li>栈</li><li>链表</li><li>图</li><li>散列表 HASH</li><li>堆</li><li>树</li><li>队列</li></ul><h2 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h2><p>算法感觉是怎么去操作我们的数据结构</p><p>排序算法 不同的排序算法执行效率是不一样的</p><ul><li>一个有限指令集，每条指令不依赖于语言</li><li>接受一些输入</li><li>产生输出</li><li>有限的步骤后会终止</li></ul><p>algorithm 解决问题的办法&#x2F;步骤逻辑</p><p>电灯不工作？ 解决问题的逻辑 一步步去完成</p><p>电源有没有接好 -&gt; 灯泡坏了 -&gt; 修理电灯</p><p>以上这个步骤就是算法</p><h2 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h2><p>栈结构</p><p>数组 可以在任意位置加入或者删除元素 会存在一些位移 效率低 使用数组是因为获取非常方便 只需要输入索引就可以拿到</p><p>栈</p><p>受限的结构 只能在栈顶一端进行添加和删除操作 栈顶元素是可以变化的</p><p>进栈 添加元素 只能在栈顶插入</p><p>出栈 删除元素</p><p>所以 后进先出 （LIFO） last in first out</p><p>生活中的栈结构 自助餐的餐盘 信箱</p><p>程序是对生活的抽象</p><p>函数调用栈<br>A 中调用了 B B 中调用的 C<br>A 入栈 B 入栈 C 入栈 D 入栈<br>然后 D-&gt;C-&gt;B-&gt;A 的方式出栈<br>A -&gt; B -&gt; C -&gt; D</p><p>递归 栈溢出 反复压入栈 无限递归</p><p>顺序进栈 可以一边进栈 一边出栈</p><p>栈结构的实现</p><p>1、基于数组实现</p><p>定义一个栈类<br><a href="https://codepen.io/treeu/pen/bGmqWZJ">https://codepen.io/treeu/pen/bGmqWZJ</a></p><p>2、基于链表实现</p><p>对数组进行包装</p><p>十进制转二进制</p><p>为什么？ 底层是二进制，最终都会转回二进制</p><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h2><p>受限的线性结构 -&gt; 有序数据元素的集合</p><p>分为前端和后端</p><p>前端 删除元素</p><p>后端 允许在后端添加元素</p><p>先进先出 first in first out FIFO</p><p>生活中 -&gt; 排队</p><p>打印队列：依次打印<br>线程队列：并行允许任务，开启多线程，线程队列，先放进去 等前一个结束再执行后面的</p><p>实现：<br>1、基于数组<br>2、基于链表 链表的效率更高</p><p>题目：击鼓传花 程序规则 参数：人和指定的数字 轮流数数 数到 5 淘汰一个人 再重新数到 5 再淘汰一个人 最后留下来的人是谁 数组下标值</p><p><a href="https://codepen.io/treeu/pen/mdzWoLo?editors=0012">https://codepen.io/treeu/pen/mdzWoLo?editors=0012</a></p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>优先级队列主要考虑的问题：</p><ul><li>每个元素不再只是一个数据，而且包含数据的优先级</li><li>在添加方式中，根据优先级放入正确的位置</li></ul><p>生活中的应用场景</p><p>登机的顺序 老年人优先之类</p><p><a href="https://codepen.io/treeu/pen/gOBXLbJ?editors=0012">https://codepen.io/treeu/pen/gOBXLbJ?editors=0012</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表和数组一样 可以用于存储一系列的元素，但是链表和数组的实现机制完全不同</p><p>不同于数组，链表中的元素在内存中不必要是连续的空间</p><p>链表中的每个元素由一个存储元素本身的节点和指向下一个元素的引用（有些语言称为指针或者连接）组成</p><h3 id="相对于数组的优势"><a href="#相对于数组的优势" class="headerlink" title="相对于数组的优势"></a>相对于数组的优势</h3><ul><li>内存空间不需要是连续的，可以充分利用计算机的内存，实现灵活的内存动态管理</li><li>链表不必在创建时就确定大小，并且大小可以无限的延伸下去</li><li>链表在插入和删除数据时，时间复杂度可以达到 O(1).相对数组的效率高很多</li></ul><p>时间复杂度是什么？O 大 O 表示法<br>时间复杂度是一个函数 （哎呀 没看懂）</p><p><a href="https://blog.csdn.net/m1195900241/article/details/118443745">https://blog.csdn.net/m1195900241/article/details/118443745</a></p><h3 id="链表的缺点"><a href="#链表的缺点" class="headerlink" title="链表的缺点"></a>链表的缺点</h3><ul><li><p>链表访问任何一个元素时，都需要从头开始访问，无法跳过第一个元素访问任何一个元素，需要从头一个一个访问</p></li><li><p>无法通过下标访问元素，还是需要一个个访问</p></li></ul><h2 id="如何选择数组还是链表"><a href="#如何选择数组还是链表" class="headerlink" title="如何选择数组还是链表"></a>如何选择数组还是链表</h2><p>需要通过下标获取数据多 使用数组</p><p>需要频繁的删除插入元素 使用链表</p><h3 id="链表是什么呢"><a href="#链表是什么呢" class="headerlink" title="链表是什么呢"></a>链表是什么呢</h3><p>链表有点像火车<br>火车头会连接一个节点 节点上有乘客（数据）并且这个节点会连接着下一个节点</p><h2 id="封装一个链表"><a href="#封装一个链表" class="headerlink" title="封装一个链表"></a>封装一个链表</h2><p><a href="https://codepen.io/treeu/pen/gOBXEww">https://codepen.io/treeu/pen/gOBXEww</a></p><h2 id="认识双向链表"><a href="#认识双向链表" class="headerlink" title="认识双向链表"></a>认识双向链表</h2><p>双向链表的特点</p><ul><li>可以使用一个 head 和一个 tail 分别指向头部和尾部的节点</li><li>每个节点都由三部分组成：前一个节点的指针（prev）&#x2F;数据&#x2F;下一个节点的指针（next）</li><li>双向链表的第一个节点 prev 是 null</li><li>双向链表的最后一个节点 next 是 null</li></ul><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>只能从头遍历到尾或者从尾遍历到头（一般从头到尾）<br>也就是链表相连的过程是单向的<br>实现的原理是上一个链表中有一个指向下一个的引用</p><h3 id="单向链表的缺点"><a href="#单向链表的缺点" class="headerlink" title="单向链表的缺点"></a>单向链表的缺点</h3><p>可以很轻松的到达下一个节点，但是回到前一个节点是比较困难的</p><p>例子：其实就是你拿到下一个节点只需要 next，但是如果你想找上一个节点，只能重头开始依次查找</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>既可以从头遍历到尾 又可以从尾遍历到头<br>也就是一个节点既有向前链接的引用也有向后连接的引用</p><h3 id="双向链表的缺点"><a href="#双向链表的缺点" class="headerlink" title="双向链表的缺点"></a>双向链表的缺点</h3><p>插入和删除操作的时候，需要考虑的是四个引用（单向只考虑两个），实现起来会困难一些</p><p>相对于单项链表，占用的空间要更大一些</p><p>（缺点微不足道 使用上会更方便）</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表通常是基于数组进行实现的，但相对于数组，它也有很多优势</p><ul><li>可以提供非常快递的插入-删除-查找操作</li><li>无论多少数据，插入和删除的值，都接近 O(1)的时间级，实际上只需要几个机器指令即可完成</li><li>哈希表的速度比树还快，基本可以瞬间查找到想要的元素</li><li>哈希表相对于树来说编码要容易很多</li></ul><p>哈希表相对于数组的不足</p><ul><li>哈希表中的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素</li><li>通常情况下，哈希表中的 key 是不允许重复的，不能放置相同的 key，用于保存不用的元素</li></ul><h1 id="哈希表是什么"><a href="#哈希表是什么" class="headerlink" title="哈希表是什么"></a>哈希表是什么</h1><p>数组 一个连续的内存空间</p><p>哈希表的结构就是数组，但它神奇的地方在于对下标值的一种变换，这种变换我们可以称之为哈希函数，通过哈希函数可以获取到 HashCode</p><h2 id="为什么需要哈希表这种结构"><a href="#为什么需要哈希表这种结构" class="headerlink" title="为什么需要哈希表这种结构"></a>为什么需要哈希表这种结构</h2><p>案例一：公司使用一种数据来保存所有员工</p><p>方案一：数组 线性查找（一个一个找）效率比较低</p><p>案例二：联系人跟电话的存储</p><p>案例三： 单词信息的储存</p><p>对应关系</p><p>比如：根据 python 找到 下标值 从数组中找到对应元素</p><p>方案目标：字符串转下标值</p><p>编码系统 比如 ASCII 编码：a &#x3D; 97 b&#x3D;98</p><p>方案一： 把单词每个字符编码求和<br>比如 Cats 3+1+20+19 &#x3D; 43<br>那么 43 就作为 cats 单词的下标存在数组中</p><p>但是这种情况的问题<br>就是可能很多单词的数组下标都是 43<br>比如 was<br>那么就会出现数据的覆盖<br>所以这种情况是不合理的</p><p>其实也就是找一种特殊的编码方式<br>让数组的下标值不能重复 值和下标值唯一对应</p><p>方案二：幂的连乘<br>比如一个数字 7654 &#x3D; 7<em>10^3 + 6</em>10^2+5^10+4<br>那么单词也可以使用这种方案来表示</p><p>cats&#x3D;3<em>27^3 + 1</em>27^2 + 20^27 + 17 &#x3D; 60337</p><p>这样得到的数字可以基本保证它的唯一性</p><p>这个方案的问题：数组的下标会很大，没几个数据，但是会申请一个很大的空间</p><h3 id="哈希化"><a href="#哈希化" class="headerlink" title="哈希化"></a>哈希化</h3><p>现在需要一种压缩方法，把幂的连乘方案中得到的巨大整数范围压缩到可接受的数组范围中</p><p>对于 50000 个数据，在实际情况中往往需要更大的空间来存储这些单词，因为我们不能保证单词会映射到每一个位置</p><p>比如两倍的大小：1000000</p><p>取余操作：</p><p>假设把从 0-199 的数字（largeNumber）代表<br>压缩到 0-9 的数字，比如使用 SmallRange 代表</p><p>下标值的结果 index &#x3D; largeNumer % smallRange</p><p>当一个数被 10 整除时，余树一定在 0-9 之间</p><p>13 % 10 &#x3D; 3</p><p>157 % 10 &#x3D; 7</p><p>当然这中间可能还是有重复<br>不过重复的值明显变少了<br>因为我们数组的范围比较大</p><p>如果要将 700000000 压缩到 100000 以内</p><p>我们可以做取余操作</p><ul><li><p>哈希化：将大数字转换为数组范围内下标的过程，我们称之为哈希化</p></li><li><p>哈希函数：通常我们会将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数就是哈希函数，也就是映射的一个过程封装成一个函数</p></li><li><p>最终将数据插入到这个数组，对整个结构的封装，我们就称之为是一个哈希表</p></li></ul><p>还有未解决的问题</p><p>如果哈希化后还存在重复 怎么处理</p><h3 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h3><ul><li>链地址法</li></ul><p>索引相同的数据 存储的不再是单个数据 而是一个链条</p><p>这个链条使用什么数据结构呢，常见的是数组和链表</p><p>查询的时候先通过哈希化的数组下标找到对应的位置，取出链表，然后通过线性查找，依次查找找到对应的数据</p><p>那到底是使用数组还是链表？</p><p>都是线性查找 效率也差不多</p><p>其实差不多，根据业务场景来选择</p><p>新插入数据多的情况下选择链表</p><p>开放因子 （还没讲）</p><p>java 链表的长度 大于 9 就换成红黑树</p><h3 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h3><p>主要工作方式是寻找空白的单元格来添加重复的数据 （使用很少）</p><p>开放因子 大于 0.75 就会开始扩容</p><p>探索这个位置的方式：</p><p>删除操作 不可以将这个位置的下标设置为 null 设置为 null 可能会影响我们之后的查询其他操作，所以通常删除一个位置的数据时，我们可以将它进行特殊处置 比如设置为-1</p><ul><li><p>线性探测<br>步长为 1 的探测 就是每次下标值都+1 - 插入 一个个加 一个个查看 直到找到 - 查询也是 先找到哈希化之后的 index，然后一个个加去查找直到数值相同，查询过程有一个约定，如果查询到空位置就停止，因为不可能跳过空位置 - 存在的问题：聚集，我们把一连串的单元格都存在填充元素就叫做聚集，聚集会影响哈希表的性能，无论是插入&#x2F;查询&#x2F;删除都存在这个问题，比如我们插入 32 然后发现临近的单元格都被放满了，这个时候线性查找就要查找很多元素，才能找到</p></li><li><p>二次探测<br>修改了步长，比如下标值 X 那么下一个就是 X+1^1 X+2^2<br>这样就可以一次探测比较长的距离，避免聚集带来的影响</p><ul><li>存在的问题： 还是会聚集 只是步长不一致的聚集 因为步长的规律是一致的</li></ul></li><li><p>再哈希法<br>哈希 通过某种算法得到数字<br>产生不同的步长</p><ul><li>stepSize &#x3D; constant - （key % constant）</li><li>其中 constant 是质数 且小于数组的容量 质数 除 1 和它本身不再有其他因数</li><li>例如： 5 - （key % 5）</li></ul></li></ul><h3 id="哈希化的效率"><a href="#哈希化的效率" class="headerlink" title="哈希化的效率"></a>哈希化的效率</h3><p>哈希表中执行插入和搜索的操作效率是非常高的</p><p>如果没有发生冲突 那么效率就会更高</p><p>如果发生冲突 存取时间就依赖后来的探测长度</p><p>平均探测长度及平均存取时间，取决于 <strong>填装因子</strong> ，填装因子变大，探测长度也会越来越大，效率就会下降， 开发地址法比链地址法更严重，我们要对比他们的效率</p><h3 id="装填因子-（填装因子）"><a href="#装填因子-（填装因子）" class="headerlink" title="装填因子 （填装因子）"></a>装填因子 （填装因子）</h3><ul><li>装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值</li><li>装填因子 &#x3D; 总数据项（已经存放的数据量）&#x2F; 哈希表长度</li></ul><p>开放地址的装填因子 最大为 1</p><p>链地址法： 可以大于 1</p><p>链地址法的效率更高 一般采用链地址法</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希表的主要优点是它的速度<br>（牺牲空间换时间）</p><p>好的哈希函数应该尽可能让计算的过程变得简单，提高计算的效率</p><p>提高速度的一个办法就是让哈希函数中尽量少的有乘法和除法，因为它们的性能是比较低的</p><p>好的哈希函数</p><ul><li>快速的计算<br>快速获取到对应的 hashCode<ul><li>多项式的优化 霍纳法则（秦九韶算法）</li><li>其实就是提取公因数 减少乘法的次数</li></ul></li><li>均匀的分布</li><li>无论是链地址法还是开放地址法，当多个元素映射到同一个位置时，都会影响效率</li><li>优秀的哈希函数应该尽可能的将元素映射到不同的位置，让元素在哈希表中均匀的分布</li><li>使用质数</li><li>哈希表的长度</li><li>N 次幂的底数</li></ul><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的特点"><a href="#树的特点" class="headerlink" title="树的特点"></a>树的特点</h2><h2 id="生活中的树"><a href="#生活中的树" class="headerlink" title="生活中的树"></a>生活中的树</h2><p>公司组织架构 倒过来的树</p><h2 id="树的术语"><a href="#树的术语" class="headerlink" title="树的术语"></a>树的术语</h2><ul><li><p>树(tree): n(n&gt;&#x3D;0) 个节点构成的有限集合<br>当 n&#x3D;0 时，称为空树</p></li><li><p>对于一个非空树，树中有一个称为根’root’的节点表示</p></li><li><p>其余节点可以分为 m(m &gt; 0)个互不相交的有限集 T，其中每个节点也可以称作一棵树，称为原来树的<strong>子树</strong> subTree</p></li><li><p>节点的度（degree） 节点的子树个数</p></li><li><p>树的度 树的所有节点中最大的度数</p></li><li><p>叶节点（leaf） 度为 0 没有子节点的节点 也称为叶子节点</p></li><li><p>父节点（parent）</p></li><li><p>子节点（Child）</p></li><li><p>兄弟节点 (sibling) 同一个父节点</p></li><li><p>路径和路径长度 路径长度是边边</p></li><li><p>节点的层次（level）规定根节点在 1 层，其它任一节点的层数是其父节点的层数+1</p></li><li><p>树的深度（Depth）：树中所有节点的最大层次上这棵树的深度</p></li></ul><h2 id="树的表示方式"><a href="#树的表示方式" class="headerlink" title="树的表示方式"></a>树的表示方式</h2><p>儿子-兄弟表示法 旋转 45 度 从上往下看 能发现这是一颗二叉树</p><h2 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h2><p>如果树中每个节点最多只能有两个子节点，这个树就是二叉树</p><p>所有的树本质上都可以使用二叉树模拟出来</p><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树可以为空 也就是没有节点</p><p>若不为空，则它上由根节点和其称为左子节点 TL 和右子树 TR 的两个不相交的二叉树组成</p><p>二叉树有五种形态</p><ul><li>空</li><li>只有一个根节点</li><li>只有一个左子节点</li><li>只有一个右子节点</li><li>有左子节点和右子节点</li></ul><h2 id="二叉树的特性"><a href="#二叉树的特性" class="headerlink" title="二叉树的特性"></a>二叉树的特性</h2><p>一个二叉树第 i 层的最大节点数为： 2^(i-1), i &gt;&#x3D; 1;</p><p>深度为 K 的二叉树有最大节点总数为：2^k - 1, k &gt;&#x3D; 1;</p><p>对任何非空二叉树 T，若 n0 表述叶节点的个数，n2 是度为 2 度非叶子节点个数，那么两者满足关系 n0&#x3D;n2+1</p><h2 id="完美二叉树"><a href="#完美二叉树" class="headerlink" title="完美二叉树"></a>完美二叉树</h2><p>除了最下面一层的叶节点外，每层节点都有两个子节点，就构成了满二叉树</p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><ul><li>除了最后一层 其他各层的节点数都达到最大个数</li><li>且最后一层从左向右的叶节点要连续存在，只缺右侧若干节点</li><li>完美二叉树是特殊的完全二叉树</li></ul><h2 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h2><p>常见的方式树树组和链表</p><p>数组针对完全二叉树好处理，非完全二叉树不太好处理，不知道这个索引怎么拿</p><p>二叉树最常见的方式还是使用链表存储</p><ul><li>每个节点封装成一个 node，node 中包含存储的数据，左节点的引用，右节点的引用</li></ul><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>可以为空</p><p>不为空的情况下，满足以下性质：</p><ul><li>非空左子树的所有键值小于其根节点的键值</li><li>非空右子树的所有键值大于其根节点的键值</li><li>左、右子树本身也是二叉搜索树</li></ul><p>简单来说就是 左边的值都要小于根节点 右边的值都要大于根节点</p><h3 id="二叉搜索树的特点"><a href="#二叉搜索树的特点" class="headerlink" title="二叉搜索树的特点"></a>二叉搜索树的特点</h3><p>相对较小的值总是保存在左节点，相对较大的值总是保存在右节点上</p><p>利用这个特点</p><p>查找效率会非常高</p><p>比如 我们的根节点是 9 那么 10 一定是在右边节点中查找</p><p>这就是二分查找的思想</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webgpu</title>
    <link href="/2023/04/03/webgpu/"/>
    <url>/2023/04/03/webgpu/</url>
    
    <content type="html"><![CDATA[<p>s</p><h1 id="webGPU"><a href="#webGPU" class="headerlink" title="webGPU"></a>webGPU</h1><p>有异步函数尽量用异步函数处理</p><p>什么可怕的语言啊 真的要死哦</p><h1 id="bindGroup-相关"><a href="#bindGroup-相关" class="headerlink" title="bindGroup 相关"></a>bindGroup 相关</h1><h2 id="着色器和绑定组布局"><a href="#着色器和绑定组布局" class="headerlink" title="着色器和绑定组布局"></a>着色器和绑定组布局</h2><p>在 sharder 中全局变量的值（公共值）都会绑定一个<br>@group 和@bingding</p><p>多个@bingding 可以共享同一个 group</p><p>在给定的@group 中必须具有唯一的但是不一定是连续的@bingding 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">@<span class="hljs-title function_">group</span>(<span class="hljs-number">0</span>) @<span class="hljs-title function_">binding</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">var</span>&lt;uniform&gt;<span class="hljs-attr">camera</span>:<span class="hljs-title class_">Camera</span><br></code></pre></td></tr></table></figure><p>在关联的应用程序代码中，需要定义一个 GPUBingGroupLayout,包含来自着色器给定的@group 中的每个@binging<br>以上述为例子</p><p>也就是 bindGroupLayout 是确认每个 group 中有多少个 bingding，对应的是同一个 group</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bindGroupLayout = gpuDevice.<span class="hljs-title function_">createBindGroupLayout</span>(&#123;<br><span class="hljs-attr">entries</span>: [<br>&#123;<br><span class="hljs-attr">bingding</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">visibility</span>: <span class="hljs-title class_">GPUshaderStage</span>.<span class="hljs-property">VERTEX</span>, <span class="hljs-comment">// FRAGMENT 用在哪个sharder中 可以用在多个</span><br><span class="hljs-attr">buffer</span>: &#123;&#125;, <span class="hljs-comment">// 以下包括它都是绑定类型，里面还可以进行一些配置，至少要设置一个空对象，不能不写，例如这里的缓冲区类型，是storage 还是 uniform</span><br><span class="hljs-attr">texture</span>: &#123;&#125;, <span class="hljs-comment">// 纹理</span><br><span class="hljs-attr">sampler</span>: &#123;&#125;, <span class="hljs-comment">// 采样器</span><br>&#125;,<br>],<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="管线和管线布局"><a href="#管线和管线布局" class="headerlink" title="管线和管线布局"></a>管线和管线布局</h2><p>绑定组布局（也就是上面的）通过 GPUPipelineLayout 传入</p><p>管线布局是管线使用 GPUBindGroupLayouts 的列表，也就是绑定几个 group（每个 group 的具体内容如上），如果只有一个，就只写一个， 案例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> piplelineLayout = gpuDevice.<span class="hljs-title function_">createPipelineLayout</span>(&#123;<br><span class="hljs-attr">bindGroupLayouts</span>: [<br>bindGroupLayout, <span class="hljs-comment">// 和上面的同名</span><br>],<br>&#125;);<br><span class="hljs-comment">// 这里还有一个auto布局是给简单管道使用的，也就是其实隐式的给你创建了group，里面所有的值都是默认值，大多情况下我们最好自己设定布局方式</span><br><span class="hljs-keyword">const</span> pipelineA = gpuDevice.<span class="hljs-title function_">createRenderPipeline</span>(&#123;<br><span class="hljs-attr">layout</span>: piplelineLayout, <span class="hljs-comment">// layout就是绑定多少个group</span><br><span class="hljs-attr">vertex</span>: &#123;<br><span class="hljs-attr">module</span>: vertexModuleA, <span class="hljs-comment">// 是哪个shader</span><br><span class="hljs-attr">entryPoint</span>: <span class="hljs-string">&#x27;vertexMain&#x27;</span>, <span class="hljs-comment">// 使用的入口函数是哪个</span><br>&#125;,<br><span class="hljs-attr">fragment</span>: &#123;<br><span class="hljs-comment">//  同上</span><br>&#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="资源和绑定组"><a href="#资源和绑定组" class="headerlink" title="资源和绑定组"></a>资源和绑定组</h2><p>做完以上操作，我们就可以给资源进行绑定了，其实 auto 就是用默认配置，我们自己写 layout 就是有些我们需要自行进行配置</p><p>这里的 GPUBindGroup，指向的是将暴露给着色器的实际数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 只是创建，数据还未绑定上</span><br><span class="hljs-keyword">const</span> cameraBuffer = gpuDevice.<span class="hljs-title function_">createBuffer</span>(&#123;<br><span class="hljs-attr">size</span>: <span class="hljs-number">144</span>, <span class="hljs-comment">// 两个4*4矩阵和一个vec3向量 这里不太清楚 vec3向量 不是 4*3吗</span><br><span class="hljs-attr">usage</span>: <span class="hljs-title class_">GPUBufferUsage</span>.<span class="hljs-property">COPY_DST</span> | <span class="hljs-title class_">GPUBufferUsage</span>.<span class="hljs-property">UNIFORM</span>,<br>&#125;);<br><span class="hljs-comment">// 其他的</span><br><span class="hljs-comment">// gpuDevice.createTexture  创建纹理</span><br><span class="hljs-comment">// gpuDevice.createSampler  创建取样器</span><br><span class="hljs-comment">// 创建完之后我们要做什么 创建完当然是要绑定 绑定的时候我们还是对应上述的layout，如果我们自己进行了设定</span><br><span class="hljs-comment">// 这里其实是做一个指向 具体数据是可以还在后面才能知道，以及更新资源其实都与这里无关</span><br><span class="hljs-keyword">const</span> bindGroup = gpuDevice.<span class="hljs-title function_">createBindGroup</span>(&#123;<br><span class="hljs-attr">layout</span>: bindGroupLayout,<br><span class="hljs-attr">entries</span>: [<br>&#123;<br><span class="hljs-attr">binding</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">resource</span>: &#123; <span class="hljs-attr">buffer</span>: cameraBuffer &#125;, <span class="hljs-comment">//只有buffer需要这样</span><br>&#125;,<br><span class="hljs-comment">// 纹理</span><br>&#123;<br><span class="hljs-attr">binding</span>: <span class="hljs-number">1</span>,<br><span class="hljs-attr">resource</span>: baseColorTexture.<span class="hljs-title function_">createView</span>(),<br>&#125;,<br>&#123;<br><span class="hljs-attr">binding</span>: <span class="hljs-number">2</span>,<br><span class="hljs-attr">resource</span>: <span class="hljs-comment">// 采样器</span><br>&#125;,<br>],<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="设置绑定组和管道"><a href="#设置绑定组和管道" class="headerlink" title="设置绑定组和管道"></a>设置绑定组和管道</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 设置数据 数据设置的是ArrayBuffer</span><br><span class="hljs-keyword">const</span> cameraArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(<span class="hljs-number">36</span>);<br>cameraArray.<span class="hljs-title function_">set</span>(viewMatrix, <span class="hljs-number">16</span>);<br><span class="hljs-comment">// 写入数据</span><br>device.<span class="hljs-property">queue</span>.<span class="hljs-title function_">writeBuffer</span>(cameraBuffer, <span class="hljs-number">0</span>, cameraArray);<br><span class="hljs-comment">// 进行渲染</span><br><span class="hljs-keyword">const</span> commandEncoder = device.<span class="hljs-title function_">createCommandEncoder</span>();<br><span class="hljs-keyword">const</span> passEncoder = commandEncoder.<span class="hljs-title function_">beginRenderPass</span>(&#123;<br><span class="hljs-comment">// 进行一些画布初始化的处理 设置颜色之类的</span><br>&#125;);<br>passEncoder.<span class="hljs-title function_">setPipeline</span>(pipelineA);<br>passEncoder.<span class="hljs-title function_">setBindGroup</span>(<span class="hljs-number">0</span>, bindGroup); <span class="hljs-comment">// 跟渲染器绑定 必须要进行设置</span><br>passEncoder.<span class="hljs-title function_">draw</span>(<span class="hljs-number">128</span>);<br>passEncoder.<span class="hljs-title function_">end</span>();<br>device.<span class="hljs-property">queue</span>.<span class="hljs-title function_">submit</span>([commandEncoder.<span class="hljs-title function_">finish</span>()]);<br></code></pre></td></tr></table></figure><h2 id="自动布局"><a href="#自动布局" class="headerlink" title="自动布局"></a>自动布局</h2><p><strong>谨慎使用</strong></p><p>如果在 createRenderPipeline 中写入的布局方式为 auto，此时管道将<strong>根据着色器中声明的绑定</strong>创建自己的内部管道布局，可以通过<code>getBindGroupLayout(index)</code>从管道中查询自动生成的布局</p><p>也就是自动生成布局了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> autoPipelineA = gpuDevice.<span class="hljs-title function_">createRenderPipeline</span>(&#123;<br><span class="hljs-attr">layout</span>: <span class="hljs-string">&#x27;auto&#x27;</span>, <span class="hljs-comment">//根据着色器的声明绑定自动生成</span><br><span class="hljs-attr">vetex</span>:.., <span class="hljs-comment">// 同上</span><br>&#125;);<br><span class="hljs-keyword">const</span> autoBindGroupA = gpuDevice.<span class="hljs-title function_">createBindGroup</span>(&#123;<br><span class="hljs-attr">layout</span>:autoPipelineA.<span class="hljs-title function_">getBindGroupLayout</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// @group(0)</span><br><span class="hljs-attr">entries</span>:[&#123;<br><span class="hljs-attr">binding</span>:<span class="hljs-number">0</span>,<br><span class="hljs-attr">resource</span>:&#123;<span class="hljs-attr">buffer</span>:cameraBuffer&#125;,<br>&#125;]<br>&#125;)<br></code></pre></td></tr></table></figure><p>此时我们看上去这个感觉更好，这不是更方便吗，为什么不建议使用呢</p><p>缺点奉上</p><ul><li><p>auto 布局是跟管线绑定的，是不能复用的，所以会出现即使是一模一样的绑定组，我们也需要创建多个 createBindGroup 进行多次绑定 增加了成本</p></li><li><p>使用 auto 生成的布局可能不是你所需要的，比如如果我们在 shader 中定义了，但是暂时没有使用，auto 布局中就不会给我们自动生成</p></li></ul><p>根据以上缺点 所以我们需要谨慎使用 auto</p><h2 id="绑定组的复用"><a href="#绑定组的复用" class="headerlink" title="绑定组的复用"></a>绑定组的复用</h2><p>可以只设置一次绑定组，让两个管道都使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">passEncoder.<span class="hljs-title function_">setBindGroup</span>(<span class="hljs-number">0</span>, bindGroup);<br>passEncoder.<span class="hljs-title function_">setPipeline</span>(pipeLineA);<br>passEncoder.<span class="hljs-title function_">draw</span>(<span class="hljs-number">128</span>);<br>passEncoder.<span class="hljs-title function_">setPipeline</span>(pipeLineA);<br>passEncoder.<span class="hljs-title function_">draw</span>(<span class="hljs-number">128</span>);<br></code></pre></td></tr></table></figure><h3 id="绑定组子集的复用"><a href="#绑定组子集的复用" class="headerlink" title="绑定组子集的复用"></a>绑定组子集的复用</h3><p>绑定组的布局怎么样 和实际使用怎么样是两回事<br>也就是说可以设置好布局 但是实际上并不使用</p><h2 id="使用多个绑定组"><a href="#使用多个绑定组" class="headerlink" title="使用多个绑定组"></a>使用多个绑定组</h2><p>那要使用多个绑定组，我们要做的事情首先就是创建多个绑定组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建多个绑定组布局</span><br><span class="hljs-keyword">const</span> layout1 = gpuDevice.<span class="hljs-title function_">createBindGroupLayout</span>(&#123;<br><span class="hljs-attr">entries</span>: [<br>&#123;<br><span class="hljs-attr">binding</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">visibility</span>: <span class="hljs-title class_">GPUShaderStage</span>.<span class="hljs-property">VERTEX</span>,<br><span class="hljs-attr">buffer</span>: &#123;&#125;,<br>&#125;,<br>],<br>&#125;);<br><span class="hljs-keyword">const</span> layout2 = gpuDevice.<span class="hljs-title function_">createBindGroupLayout</span>(&#123;<br><span class="hljs-attr">entries</span>: [<br>&#123;<br><span class="hljs-attr">binding</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">visibility</span>: <span class="hljs-title class_">GPUShaderStage</span>.<span class="hljs-property">VERTEX</span>,<br><span class="hljs-attr">buffer</span>: &#123;&#125;,<br>&#125;,<br>],<br>&#125;);<br><span class="hljs-comment">// 将绑定组布局与管道布局绑定</span><br><span class="hljs-keyword">const</span> pipelineLayout = gpuDevice.<span class="hljs-title function_">createPipelineLayout</span>(&#123;<br><span class="hljs-attr">bingGroupLayouts</span>: [layout1, layout2], <span class="hljs-comment">// 这里也就是 group(0),group(1)</span><br>&#125;);<br><span class="hljs-comment">// 绑定组与绑定组布局的指向绑定</span><br><span class="hljs-keyword">const</span> cameraGroup = gpuDevice.<span class="hljs-title function_">createBindGroup</span>(&#123;<br><span class="hljs-attr">layout</span>: layout1,<br><span class="hljs-attr">entries</span>: [<br>&#123;<br><span class="hljs-attr">binding</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">resource</span>: &#123; <span class="hljs-attr">buffer</span>: cameraBuffer &#125;, <span class="hljs-comment">//这里前面应该要创建buffer，但是可以在后面再写入</span><br>&#125;,<br>],<br>&#125;);<br><span class="hljs-keyword">const</span> cameraGroup2 = gpuDevice.<span class="hljs-title function_">createBindGroup</span>(&#123;<br><span class="hljs-attr">layout</span>: layout1,<br><span class="hljs-attr">entries</span>: [<br>&#123;<br><span class="hljs-attr">binding</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">resource</span>: &#123; <span class="hljs-attr">buffer</span>: cameraBuffer &#125;, <span class="hljs-comment">//这里前面应该要创建buffer，但是可以在后面再写入</span><br>&#125;,<br>],<br>&#125;);<br>passEncoder.<span class="hljs-title function_">setBindGroup</span>(<span class="hljs-number">0</span>, cameraGroup); <span class="hljs-comment">// group(0)</span><br>passEncoder.<span class="hljs-title function_">setBindGroup</span>(<span class="hljs-number">1</span>, cameraGroup2); <span class="hljs-comment">// group(1)</span><br></code></pre></td></tr></table></figure><h3 id="注意-一次能创建多少个绑定组和绑定组中一次最多能绑定几个资源-这些是要去查的"><a href="#注意-一次能创建多少个绑定组和绑定组中一次最多能绑定几个资源-这些是要去查的" class="headerlink" title="注意 一次能创建多少个绑定组和绑定组中一次最多能绑定几个资源 这些是要去查的"></a>注意 一次能创建多少个绑定组和绑定组中一次最多能绑定几个资源 这些是要去查的</h3><p><code>limits.maxBindGroups</code> 目前看是最多绘制 4 个组</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>最佳性能，使用@group(0) 去绘制变化最少的值<br>后续的 group 去绘制变化频次相对高的数据</p><h2 id="使用上"><a href="#使用上" class="headerlink" title="使用上"></a>使用上</h2><p>不使用的部分可以在 shader 中直接不写，但是绑定的时候还是需要绑定</p><h1 id="图片纹理部分"><a href="#图片纹理部分" class="headerlink" title="图片纹理部分"></a>图片纹理部分</h1><p>尽可能的使用压缩格式</p><h2 id="格式之间的比较"><a href="#格式之间的比较" class="headerlink" title="格式之间的比较"></a>格式之间的比较</h2><p>大概只有以下几种</p><ul><li>webp 首选 体积小 无损&#x2F;有损 以及透明度支持 就是还不是广泛支持</li><li>png 有更大的文件大小 无损&#x2F;支持透明度</li><li>jpg 不支持透明度 大小跟 webp 差不多 最普遍的图像格式</li></ul><p>GIF 不行 质量差 一定要用到最好用视频格式</p><h2 id="从图像-URL-创建纹理"><a href="#从图像-URL-创建纹理" class="headerlink" title="从图像 URL 创建纹理"></a>从图像 URL 创建纹理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">webGPUTextureFromImageBitmapOrcanvas</span>(<span class="hljs-params">gpuDevice, source</span>) &#123;<br><span class="hljs-keyword">const</span> textureDescriptor = &#123;<br><span class="hljs-attr">size</span>: &#123; <span class="hljs-attr">width</span>: source.<span class="hljs-property">width</span>, <span class="hljs-attr">height</span>: source.<span class="hljs-property">height</span> &#125;, <span class="hljs-comment">// 在创建纹理时就需要设置纹理的大小，所以必须要等待图像加载完成</span><br><span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;rgba8unorm&#x27;</span>,<br><span class="hljs-attr">usage</span>: <span class="hljs-title class_">GPUTextureUsage</span>.<span class="hljs-property">TEXTURE_BINDING</span> | <span class="hljs-title class_">GPUTextureUsage</span>.<span class="hljs-property">COPY_DST</span>,<br>&#125;;<br><span class="hljs-keyword">const</span> texture = gpuDevice.<span class="hljs-title function_">createTexture</span>(textureDescriptor);<br>gpuDevice.<span class="hljs-property">queue</span>.<span class="hljs-title function_">copyExternalImageToTexture</span>(<br>&#123; source &#125;,<br>&#123; texture &#125;,<br>textureDescriptor.<span class="hljs-property">size</span><br>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">webGPUTextureFromImageUrl</span>(<span class="hljs-params">gpuDevice, url</span>) &#123;<br><span class="hljs-comment">// 重点就是fetch了</span><br><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br><span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">blob</span>();<br><span class="hljs-keyword">const</span> imgBitMap = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createImageBitMap</span>(blob);<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">webGPUTextureFromImageBitmapOrCanvas</span>(gpuDevcie, imgBitMap);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="从标签创建纹理"><a href="#从标签创建纹理" class="headerlink" title="从标签创建纹理"></a>从<img>标签创建纹理</h2><p><code>createImageBitmap()</code>是一定要保证图像加载完的<br>如果我们使用 dom 元素的情况下,要确保图片加载完</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">webGPUTextureFromImageElement</span>(<span class="hljs-params">gpuDevice, imgElement</span>) &#123;<br><span class="hljs-comment">// HTMLImageElement.complete 确认图片是否加载完成</span><br><span class="hljs-keyword">if</span> (imgElement.<span class="hljs-property">complete</span>) &#123;<br><span class="hljs-keyword">const</span> imgBitmap = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createImageBitmap</span>(imgElement);<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">webGPUTextureFromImageBitmapOrCanvas</span>(gpuDevcie, imgBitMap);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// load事件在图片加载完成时触发</span><br>imgElement.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br><span class="hljs-keyword">const</span> imgBitmap = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createImageBitmap</span>(imgElement);<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">webGPUTextureFromImageBitmapOrCanvas</span>(gpuDevcie, imgBitMap);<br>&#125;);<br><span class="hljs-comment">// 再监听一个加载失败的情况</span><br>imgElement.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;error&#x27;</span>, reject);<br>&#125;);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="应用-glTF"><a href="#应用-glTF" class="headerlink" title="应用 glTF"></a>应用 glTF</h2><p>一个 3d 模型结构 目前没有使用到 就简单看了一下</p><h2 id="从-canvas-创建纹理"><a href="#从-canvas-创建纹理" class="headerlink" title="从 canvas 创建纹理"></a>从 canvas 创建纹理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这里都不用异步哦 仅适用于具有web GPL或canvas2D上下文的画布</span><br><span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;canvas&#x27;</span>);<br><span class="hljs-keyword">const</span> texture = <span class="hljs-title function_">webGPUTextureFromImageBitmapOrCanvas</span>(gpuDevcie, canvas);<br></code></pre></td></tr></table></figure><h2 id="从-video-中创建纹理"><a href="#从-video-中创建纹理" class="headerlink" title="从 video 中创建纹理"></a>从 video 中创建纹理</h2><p>和 canvas 一样，可以将元素 video 传过去，并使用生成的 imageBitmap</p><p>视频的本质是会频繁更新，所以有点不一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> texture = gpuDevice.importExternalTexture(&#123; <span class="hljs-attr">source</span>: video &#125;);<br></code></pre></td></tr></table></figure><p><strong>得注意一下生命周期</strong></p><h2 id="生成-Mipmap"><a href="#生成-Mipmap" class="headerlink" title="生成 Mipmap"></a>生成 Mipmap</h2><p>多级渐远纹理</p><p>这个不是很懂啊，纹理部分太薄弱了啊</p><p>仔细一想不是跟 buffer 一样的吗 反正都是传递到 shader 中使用的东西</p><h2 id="计算管线"><a href="#计算管线" class="headerlink" title="计算管线"></a>计算管线</h2><p>GPU 的并行计算效率更高</p><p>使用计算管线并不需要去配置 canvas 的相关信息</p><p>创建 pipeline <code>createComputepipelineAsync(descriptor)</code></p><p>描述器：descriptor 就是指定 layout 和 compute</p><p>webgpu 中有两种传递数据的方式</p><p>顶点插槽和 bindGroup</p><ul><li>顶点插槽 setVertexBuffer 绑定顶点数据的 传递的都是 gpuBuffer</li></ul><p>两者有什么区别呢？</p><p>方式问题吧 我们绘制图形肯定需要顶点信息 这个时候就使用顶点插槽<br>其他相关的辅助信息就丢到 bindgroup 里面去</p><p>顶点插槽获取到的数据就是 main 的参数@location(0)</p><p>bindGroup 我们一般作为全局变量</p>]]></content>
    
    
    
    <tags>
      
      <tag>webgpu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>car</title>
    <link href="/2023/03/13/car/"/>
    <url>/2023/03/13/car/</url>
    
    <content type="html"><![CDATA[<h2 id="东周科目三"><a href="#东周科目三" class="headerlink" title="东周科目三"></a>东周科目三</h2><p>这是我第二次考科目三了 又是在这种忙碌又有压力的日子 当作回忆录了</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>遇到任何突发情况，无法确定怎么处理的情况，踩离合踩刹车，停车，回空档挂一档重新起步，不要紧张不要着急</p><p>三档四档跑的时候，记得给油，油门要给到 1</p><p>红绿灯路口，绿灯直接过去记得点刹</p><p>绕车一周 左后角是第一个按钮 右后角第二个 （请验证指纹）</p><p>车门要关好</p><p>上车调整座椅（下面） 靠背（左边） 系好安全带 看看后视镜是否需要调整，内侧 1&#x2F;3，外侧 2&#x2F;3， 确认灯光的关闭情况，按指纹</p><p>变更车道，超车，返回原车道，自主变道，都要看看后方是否有来车</p><p>灯光一定要记住</p><ul><li>夜间通过无信号灯的路口 闪灯 3 次</li></ul><h3 id="三号线"><a href="#三号线" class="headerlink" title="三号线"></a>三号线</h3><p>首先回忆一下路线图</p><p>起步上四档</p><p>三档加速到 1.8 踩离合 反手拉上四档 慢慢松开离合 数 7 秒 （看路况是否需要踩离合 退回三档）记得给油</p><h4 id="前方路口请右转"><a href="#前方路口请右转" class="headerlink" title="前方路口请右转"></a>前方路口请右转</h4><p>语音播报：前方路口请右转 （路牌前就可以开始注意准备停车了，避免开快了，跑到实线那边了 ）此时需要变更车道到最右侧车道，变更车道要注意看后方是否有车，变更车道后记得上个二档，避免一档超距离；</p><h4 id="前方路口请右转-1"><a href="#前方路口请右转-1" class="headerlink" title="前方路口请右转"></a>前方路口请右转</h4><p>语音再次播报：前方路口请右转 ，此时踩离合踩刹车，打右灯，（灯方一针想一想）；不用预留车位，盖箭头停车，重新挂一档，注意观察行人，等绿灯亮了再走，这里右转是走<strong>中间车道</strong></p><h4 id="前方直行通过路口"><a href="#前方直行通过路口" class="headerlink" title="前方直行通过路口"></a>前方直行通过路口</h4><p>语音播报：前方直行通过路口，注意交通信号灯，直行通过路口，可以预留一个车位，灯方一针，重新挂一档</p><h4 id="请完成超车动作"><a href="#请完成超车动作" class="headerlink" title="请完成超车动作"></a>请完成超车动作</h4><p>语音播报：请完成超车动作，超车都是从左边超车，灯方一针</p><h4 id="请返回原车道"><a href="#请返回原车道" class="headerlink" title="请返回原车道"></a>请返回原车道</h4><p>语音播报：请返回原车道，灯方一针，（如果觉得可能会超 1 档距离，可以停下来一下）</p><h4 id="超车项目完成"><a href="#超车项目完成" class="headerlink" title="超车项目完成"></a>超车项目完成</h4><p>语音播报：超车项目完成；这里需要自主变更车道到最左侧，因为前方需要掉头；</p><h4 id="前方请选择合适地点掉头"><a href="#前方请选择合适地点掉头" class="headerlink" title="前方请选择合适地点掉头"></a>前方请选择合适地点掉头</h4><p>语音播报：前方请选择合适地点掉头，靠最左边车道走</p><h4 id="请掉头"><a href="#请掉头" class="headerlink" title="请掉头"></a>请掉头</h4><p>语音播报：请掉头，盖箭头停车，灯方一针，此时前面会有红绿灯，需要观察路况，看是否能进行掉头，或是继续等待，肩膀到斑马线上，方向盘左打死，进最左边车道，摆正加速上个二档</p><h4 id="掉头结束"><a href="#掉头结束" class="headerlink" title="掉头结束"></a>掉头结束</h4><p>语音播报：掉头结束</p><p><strong>三号线掉头之后全程二档</strong> 这里有公交站台点刹项目，直线行驶项目</p><p><strong>公交站台前面有个路口</strong>，左边应该也有个白色油漆树，在这里点刹三下</p><h4 id="请保持直线行驶"><a href="#请保持直线行驶" class="headerlink" title="请保持直线行驶"></a>请保持直线行驶</h4><p>语音播报：请保持直线行驶</p><h4 id="直线行驶结束"><a href="#直线行驶结束" class="headerlink" title="直线行驶结束"></a>直线行驶结束</h4><p>语音播报：直线行驶结束</p><h4 id="前方直行通过路口-1"><a href="#前方直行通过路口-1" class="headerlink" title="前方直行通过路口"></a>前方直行通过路口</h4><p>语音播报：前方直行通过路口 进入从左至右第二个车道，停车，等待红绿灯，灯方一针</p><p>这部分没项目，可以补个四档</p><h4 id="前方路口请左转"><a href="#前方路口请左转" class="headerlink" title="前方路口请左转"></a>前方路口请左转</h4><p>语音播报：前方路口请左转</p><h4 id="前方路口请左转-1"><a href="#前方路口请左转-1" class="headerlink" title="前方路口请左转"></a>前方路口请左转</h4><p>语音再次播报：前方路口请左转，灯方一针，左转预留一个车位，因为要上二档，左转到最左边车道，红绿灯</p><h4 id="请会车"><a href="#请会车" class="headerlink" title="请会车"></a>请会车</h4><p>语音播报：请会车，点刹一下</p><h4 id="请变更车道"><a href="#请变更车道" class="headerlink" title="请变更车道"></a>请变更车道</h4><p>语音播报：请变更车道，到右边去，灯方一针，注意后方有没有车，变更车道后上二档</p><h4 id="前方终点区域"><a href="#前方终点区域" class="headerlink" title="前方终点区域"></a>前方终点区域</h4><p>语音播报：前方终点区域，注意不要在网格线停车，停车，打右灯，灯方一针<br>有车多等一下，避免影响靠边停车</p><h4 id="靠边停车"><a href="#靠边停车" class="headerlink" title="靠边停车"></a>靠边停车</h4><p>靠边停车：右灯数五秒，雨刮器对点，闭上左眼（靠窗），超过黄线之后回 45 度，再去压线，超过之后立刻停车，空档手刹</p><h2 id="六号线"><a href="#六号线" class="headerlink" title="六号线"></a>六号线</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webGL</title>
    <link href="/2023/03/11/webGL/"/>
    <url>/2023/03/11/webGL/</url>
    
    <content type="html"><![CDATA[<h2 id="webGpu"><a href="#webGpu" class="headerlink" title="webGpu"></a>webGpu</h2><p>下载最新的 Chrome Canary</p><p>打开：chrome:&#x2F;&#x2F;flags&#x2F;#enable-unsafe-webgpu</p><p>重启后生效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-comment">// 判断条件</span><br>navigator.<span class="hljs-property">gpu</span>;<br></code></pre></td></tr></table></figure><h2 id="webgl"><a href="#webgl" class="headerlink" title="webgl"></a>webgl</h2><p>webGL 使用正交右手坐标系，每个方向都有可使用的值的区间，超过该矩形区间的图像不会被绘制</p><p>目前我们看到的是 2D 绘图环境，也就是窗口的坐标系，原点为左上角，x 的正方向向右，y 轴的正方形向下，canvas 中的坐标单位都是 px</p><h3 id="渲染管线-按以下顺序逐级处理数据"><a href="#渲染管线-按以下顺序逐级处理数据" class="headerlink" title="渲染管线 按以下顺序逐级处理数据"></a>渲染管线 按以下顺序逐级处理数据</h3><ul><li>顶点缓冲区： 缓冲区 代加工数组<ul><li>数据</li></ul></li><li>顶点着色器 - 可编程的功能单元</li><li>图元装配：做什么</li><li>光栅器</li><li>片元着色器 - 可编程的功能单元</li><li>数据</li><li>纹理缓冲区</li><li>归属测试</li><li>模版测试</li><li>深度测试<ul><li>深度缓冲区</li></ul></li><li>融合</li><li>抖动</li><li>颜色缓冲区</li></ul><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>用像素画出来</p><p>webGL 在电脑的 GPU 上运行，需要能在 GPU 上能够使用的代码</p><h3 id="成对运行"><a href="#成对运行" class="headerlink" title="成对运行"></a>成对运行</h3><ul><li>顶点着色器<ul><li>计算顶点的位置</li></ul></li><li>片段着色器<ul><li>计算出当前绘制图元的每一个像素值</li></ul></li></ul><p>配对使用 组合起来称为一个着色程序</p><p>通过<code>gl.drawArrays</code>或者<code>gl.drawElement</code>运行一个着色方法对</p><p><del><strong>这对方法对所需要的任何数据都需要发送到 GPU</strong></del></p><h3 id="着色器获取数据的四种方法"><a href="#着色器获取数据的四种方法" class="headerlink" title="着色器获取数据的四种方法"></a>着色器获取数据的四种方法</h3><ul><li>属性（attributes）和缓冲<ul><li>缓存是发送到 GPU 的一些二进制序列</li><li>属性用于指明怎么从缓存中获取数据，并把数据提供给顶点着色器</li><li>目前感觉像是 key:data 属性是 key 缓冲是 data</li></ul></li><li>全局变量（uniforms）<ul><li>全局变量在着色器运行之前赋值，在运行过程中全局有效</li></ul></li><li>纹理（Textures）<ul><li>数据序列 大多数情况下存放的是图像数据</li></ul></li><li>可变量（varyings）<ul><li>顶点着色器给片段着色器传值的方式，根据渲染的图元是点、线、还是三角形，顶点着色器中设置的可变量会在片段着色器中获取不同的插值</li></ul></li></ul><h3 id="webGL-只关心两件事"><a href="#webGL-只关心两件事" class="headerlink" title="webGL 只关心两件事"></a>webGL 只关心两件事</h3><ul><li>裁剪空间的坐标值——顶点着色器提供</li><li>裁剪空间的颜色值——片段着色器提供</li></ul><p><strong>裁剪空间的范围永远是 -1 到 1</strong></p><h2 id="webGL-画布尺寸"><a href="#webGL-画布尺寸" class="headerlink" title="webGL 画布尺寸"></a>webGL 画布尺寸</h2><p>每个画布都有两个尺寸<br><code>drawingbuffer</code> 表示画布中有多少个像素<br>设置的 css 决定画布显示的尺寸</p><p>如果想让画布填充窗口</p><ul><li>设置 css <code>width:100vw</code></li><li>将<code>drawingbuffer</code>的尺寸设置为浏览器拉伸后的画布尺寸<ul><li>clientWidth clinetHeight 获取元素显示的尺寸</li><li><code>canvas.width = canvas.clinetHeight</code></li></ul></li><li>调用 gl.viewport 设置可视区域<ul><li><code>gl.viewport(0,0,gl.canvas.width,gl.canvas.height)</code></li></ul></li></ul><h2 id="webGL-在-GPU-上究竟做了什么"><a href="#webGL-在-GPU-上究竟做了什么" class="headerlink" title="webGL 在 GPU 上究竟做了什么"></a>webGL 在 GPU 上究竟做了什么</h2><ul><li>1、将顶点（或数据流）转换到裁剪空间坐标</li><li>2、基于第一部分的结果绘制像素点</li></ul><h3 id="varying"><a href="#varying" class="headerlink" title="varying"></a>varying</h3><p>在顶点着色器中定一个 varying 来给片段着色器传值<br><code>varying vec4 v_color</code><br>在片段着色器中定义同名的 varying 变量<br>webGL 会将同名的可变量从顶点着色器输入到片段着色器中</p><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p><a href="https://juejin.cn/post/6857032330863706120">https://juejin.cn/post/6857032330863706120</a></p><p>顶点着色器是唯一可以从缓存中读取值的地方，可以通过 varying 修饰同名变量，将值传递给片元着色器</p><p>缓冲区是驻存于内存中的 javascript 对象</p><p>缓冲区是一个对列，着色器每处理完一个顶点（或和顶点对应的其他 attribute 对象），缓冲区就提供下一个顶点给着色器处理</p><p>缓冲操作是在 GPU 上获取顶点和其他顶点数据的方式</p><ul><li><code>gl.createBuffer</code> 创建一个缓冲</li><li><code>gl.bindBuffer</code> 设置缓存为当前使用缓存</li><li><code>gl.bufferData</code> 将数据拷贝到缓冲</li></ul><p>webGL 如何从缓冲中提取数据传给顶点着色器属性？</p><ul><li>获取 webGL 给属性分配的地址<br><code>var postionLocation = gl.getAttribLocation(program,&#39;a_position&#39;)</code></li></ul><p>以上一般在初始化完成</p><p>知道了属性的地址，绘制前还需要发出的三个命令</p><ul><li><p>告诉 webGL 我们想从缓冲中提取数据<br><code>gl.enableVertextAttribArray(postionLocation(属性地址))</code></p></li><li><p>将缓冲绑定到 ARRAY_BUFFER 绑定点, 第一个参数，存储缓存区的目标类型，第二个参数为自己创建的缓存区的对象</p><ul><li><p><code>gl.ARRAY_BUFFER</code> 缓存区中包含了顶点对象</p></li><li><p><code>gl.ELEMENT_ARRAY_BUFFER</code> 缓存区内包含了顶点数据的索引值</p><p><code>gl.bindBuffer(gl.ARRAY_BUFFER, somebuffer(createBuffer()我们创建的buffer名称) )</code></p></li></ul></li><li><p>告诉 webGL 从 ARRAY_BUFFER 绑定点当前绑定的缓存中获取数据</p><ul><li><p><code>gl.vertexAttribpointer(...)</code></p></li><li><p>传递的参数</p><ul><li>location attribute 变量的存储位置</li><li>numComponents 缓冲区中每个顶点的分量个数 范围为 1-4 size</li><li>typeofData 指定数据类型<ul><li>gl.BYTE 字节型 [-128, 127]</li><li>gl.SHORT 短整型 [-32768, 32767]</li><li>gl.UNSIGNED_BYTE 无符号字节型 [0, 255]</li><li>gl.UNSIGNED_SHORT 无符号短整型 [0, 65535]</li><li>gl.FLOAT 浮点型(default)</li></ul></li><li>normalizeFlag<br><strong>是否将非浮点型的数据归一化到[0,1]或[-1,1]</strong><br>标准化标记，适用于所有非浮点型数据，传递 false 就解读原数据类型 [false|true]<br>如果标准化标记设为 true，BYTE 数据的值(-128 to 127)将会转换到 -1.0 到 +1.0 之间， UNSIGNED_BYTE (0 to 255) 变为 0.0 到 +1.0 之间，SHORT 也是转换到 -1.0 到 +1.0 之间， 但比 BYTE 精确度高。<br>最常用的是标准化颜色数据。大多数情况颜色值范围为 0.0 到 +1.0。 使用 4 个浮点型数据存储红，绿，蓝和阿尔法通道数据时，每个顶点的颜色将会占用 16 字节空间， 如果你有复杂的几何体将会占用很多内存。代替的做法是将颜色数据转换为四个 UNSIGNED_BYTE ， 其中 0 表示 0.0，255 表示 1.0。现在每个顶点只需要四个字节存储颜色值，省了 75% 空间<br><code>var type = gl.UNSIGNED_BYTE;</code><br><code>var normalize = true;  </code></li><li>strideToNextPieceOfData 从一个数据到下一个数据要跳过多少位 指定相邻的两个顶点间的字节数，[0-255]</li><li>offsetIntoBuffer 0 从缓冲起始位置开始读 指定缓冲区对象的偏移量，即 attribute 变量从缓冲区中的何处开始储存（从 0 开始）</li></ul></li></ul></li></ul><h2 id="着色器和-GLSL"><a href="#着色器和-GLSL" class="headerlink" title="着色器和 GLSL"></a>着色器和 GLSL</h2><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>生成裁剪空间坐标值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 每个顶点调用一次顶点着色器，每次调用都需要设置一个特殊的全局变量</span><br>  <span class="hljs-comment">// 该值为裁剪空间的坐标值</span><br>  gl_position = xxx<br>&#125;<br></code></pre></td></tr></table></figure><p>顶点着色器需要的数据，可以通过以下三种方式获得</p><ul><li>attributes 属性（从缓冲中获取的数据）<ul><li>属性可以用 float, vec2, vec3, vec4, mat2, mat3 和 mat4 数据类型。</li><li>todo：了解数据类型</li></ul></li><li>Uniforms 全局变量（在一次绘制中对所有顶点保持一致）<ul><li>全局变量属于单个着色程序</li><li>全局变量有很多种类型</li></ul></li><li>Textures 纹理（从像素或纹理元素中获取数据）</li></ul><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><p>片段着色器的作用数为当前光栅化档像素提供颜色值</p><p>每个像素都会调用一次片段着色器，每次调用都会从特殊全局变量 gl_FragColor 中获取颜色信息</p><p>片段着色器所需数据，可以通过以下三种方式获取</p><ul><li>Uniforms 全局变量</li><li>Textures 纹理</li><li>Varyings 可变量</li></ul><h2 id="GLSL-Graphics-Library-Shader-Language"><a href="#GLSL-Graphics-Library-Shader-Language" class="headerlink" title="GLSL Graphics Library Shader Language"></a>GLSL Graphics Library Shader Language</h2><p>着色器使用的语言，目的是为栅格化图像提供常用的计算功能<br>内建的数据类型</p><p>是强类型语言，不能随意赋值</p><ul><li>vec2 vec3 两个值，三个值，和四个值</li><li>mat2 mat3 mat4 2*2 矩阵<br>可以处理矩阵乘法以及矢量和矩阵的乘法</li></ul><h2 id="webGL-开启只绘制正面或者反面三角形"><a href="#webGL-开启只绘制正面或者反面三角形" class="headerlink" title="webGL 开启只绘制正面或者反面三角形"></a>webGL 开启只绘制正面或者反面三角形</h2><p>webGL 的三角形有正反面的 正面三角形顺时针 反面三角形<br>默认值为剔除反面的三角形<br><code>gl.enable(gl.CULL_FACE)</code></p><h2 id="深度缓冲"><a href="#深度缓冲" class="headerlink" title="深度缓冲"></a>深度缓冲</h2><p><code>gl.enable(gl.DEPTH_TEST)</code><br>开始绘制前需要清除深度缓冲<br><code>gl.clear(gl.COLOR_BUFFR_BIT ｜ gl.DEPTH_BUFFER_BIT)</code></p><h2 id="正射投影"><a href="#正射投影" class="headerlink" title="正射投影"></a>正射投影</h2><h2 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h2><h2 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h2><h3 id="什么是-buffer"><a href="#什么是-buffer" class="headerlink" title="什么是 buffer"></a>什么是 buffer</h3><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/457799836">https://zhuanlan.zhihu.com/p/457799836</a></p><p>缓冲区对象是 webgl 系统中的一块内存区域<br>缓冲区对象，一次可以向着色器传入多个顶点数据（充分发挥 GPU 的并行渲染能力）</p><h3 id="gl-drawArrays-mode-first-count"><a href="#gl-drawArrays-mode-first-count" class="headerlink" title="gl.drawArrays(mode,first,count)"></a>gl.drawArrays(mode,first,count)</h3><p>三个参数：</p><ul><li>mode webgl 的绘制方式</li><li>first 指定从哪个顶点开始绘制</li><li>count 当前绘制需要用到几个顶点</li></ul><h2 id="如何使用缓冲区"><a href="#如何使用缓冲区" class="headerlink" title="如何使用缓冲区"></a>如何使用缓冲区</h2><h3 id="创建缓冲区对象-gl-createBuffer"><a href="#创建缓冲区对象-gl-createBuffer" class="headerlink" title="创建缓冲区对象 gl.createBuffer()"></a>创建缓冲区对象 <code>gl.createBuffer()</code></h3><p>在内存中分配一块缓冲区对象</p><p><code>const buffer = gl.createBuffer();</code></p><p>有创建就有删除 <code>gl.deleteBuffer()</code></p><h3 id="绑定缓冲区对象-gl-bindBuffer"><a href="#绑定缓冲区对象-gl-bindBuffer" class="headerlink" title="绑定缓冲区对象 gl.bindBuffer()"></a>绑定缓冲区对象 <code>gl.bindBuffer()</code></h3><p>buffer 存在不同的类型，所以需要指定<br><code>gl.ARRAY_BUFFER</code> 包含顶点属性档 buffer，如顶点坐标，纹理坐标数据或顶点颜色数据<br>…<br><code>gl.ELEMENT_ARRAY_BUFFER</code> 用于元素索引的 Buffer。<br>…<br>webgl2 还有一些其他的<br><code>gl.bindBuffer(gl.ARRAY_BUFFER ,buffer)</code></p><h3 id="将数据写入缓冲区对象-gl-bufferData"><a href="#将数据写入缓冲区对象-gl-bufferData" class="headerlink" title="将数据写入缓冲区对象 gl.bufferData()"></a>将数据写入缓冲区对象 <code>gl.bufferData()</code></h3><p>为了优化性能，webGL 需要同时处理大量相同类型的数据，事先知道数组档类型，处理起来会更高效<br>所以定义顶点数据的时候加上类型</p><p><code>const vertices = new Float32Array([0.0,0.5,-0.5,-0.5,0.5,-0.5])</code>;</p><p><code>gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW)</code></p><p>第三个参数，指定数据存储区的使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/bufferData">https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/bufferData</a></p><p>gl.STATIC_DRAW: 缓冲区的内容可能经常使用，而不会经常更改。内容被写入缓冲区，但不被读取。<br>gl.DYNAMIC_DRAW: 缓冲区的内容可能经常被使用，并且经常更改。内容被写入缓冲区，但不被读取。<br>gl.STREAM_DRAW: 缓冲区的内容可能不会经常使用。内容被写入缓冲区，但不被读取。</p><h3 id="将缓冲区对象分配给一个-attribute-对象-gl-vertexAttribPointer"><a href="#将缓冲区对象分配给一个-attribute-对象-gl-vertexAttribPointer" class="headerlink" title="将缓冲区对象分配给一个 attribute 对象 gl.vertexAttribPointer()"></a>将缓冲区对象分配给一个 attribute 对象 <code>gl.vertexAttribPointer()</code></h3><p>找到对应 attribute 变量的位置，<br><code>const a_Position =  gl.getAttribLocation(gl.program, &#39;a_position&#39;)</code></p><h3 id="开启-attribute-对象gl-enableVertexAttribArray-a-Position"><a href="#开启-attribute-对象gl-enableVertexAttribArray-a-Position" class="headerlink" title="开启 attribute 对象gl.enableVertexAttribArray(a_Position)"></a>开启 attribute 对象<code>gl.enableVertexAttribArray(a_Position)</code></h3><p>将缓冲区对象跟 attribute 变量连接起来</p><h2 id="空间坐标"><a href="#空间坐标" class="headerlink" title="空间坐标"></a>空间坐标</h2><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/#_1">https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/#_1</a></p><p>观察空间 -&gt; 裁剪空间<br>canvas 的坐标与裁剪空间坐标的转换<br><a href="https://juejin.cn/post/7130571019940544520">https://juejin.cn/post/7130571019940544520</a></p><p><a href="https://blog.csdn.net/u011332271/article/details/110477155">https://blog.csdn.net/u011332271/article/details/110477155</a></p><p><a href="https://segmentfault.com/a/1190000042256231">https://segmentfault.com/a/1190000042256231</a></p><p>投影：正射投影和透视投影</p><p>glOrtho 函数只是负责使用什么样的视景体来截取图像，并不负责使用某种规则把图像呈现在屏幕上。<br>glViewport 主要完成这样的功能。它负责把视景体截取的图像按照怎样的高和宽显示到屏幕上。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>matrix</title>
    <link href="/2023/03/05/matrixClass/"/>
    <url>/2023/03/05/matrixClass/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span> &#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">rows, cols, data = []</span>) &#123;<br><span class="hljs-comment">// 设置行</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span> = rows;<br><span class="hljs-comment">// 设置列</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span> = cols;<br><span class="hljs-comment">// 判断是否存在矩阵数据，</span><br><span class="hljs-keyword">if</span> (data.<span class="hljs-property">length</span>) &#123;<br><span class="hljs-comment">// 矩阵数据长度要与行和列匹配</span><br><span class="hljs-keyword">if</span> (data.<span class="hljs-property">length</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>) &#123;<br><span class="hljs-comment">// 抛出错误</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;矩阵数据长度与行、列不对应&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 设置数据</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 没有则创建一个长度为rows*cols的全0数组，用于输出数据</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(rows * cols).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 获取row行col列的数据 例：1行2列 row：1 col：2</span><br><span class="hljs-title function_">get</span>(<span class="hljs-params">row, col</span>) &#123;<br><span class="hljs-comment">// 从数组中拿到数据 数组下标从0开始</span><br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[(row - <span class="hljs-number">1</span>) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span> + (col - <span class="hljs-number">1</span>)];<br>&#125;<br><span class="hljs-comment">// 设置row行col列的数据</span><br><span class="hljs-title function_">set</span>(<span class="hljs-params">row, col, value</span>) &#123;<br><span class="hljs-comment">// 0没有负数 在设置部分处理</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(value) === <span class="hljs-number">0</span>) &#123;<br>value = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 设置数组中的数组 数组下班从0开始</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[(row - <span class="hljs-number">1</span>) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span> + (col - <span class="hljs-number">1</span>)] = value;<br>&#125;<br><span class="hljs-comment">// 矩阵乘法 数学公式法</span><br><span class="hljs-title function_">multiply</span>(<span class="hljs-params">other</span>) &#123;<br><span class="hljs-comment">// 矩阵乘法条件 当A列=B行，AB可以相乘</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span> !== other.<span class="hljs-property">rows</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;第一个矩阵中的列数必须等于第二个矩阵中的行数&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 初始化一个全0矩阵 行为A的行 列为B的列</span><br><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>, other.<span class="hljs-property">cols</span>);<br><span class="hljs-comment">// 进行遍历行和列，设置新的矩阵值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= other.<span class="hljs-property">cols</span>; j++) &#123;<br><span class="hljs-comment">// 求和</span><br><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// C中的第i行j列 为A的第i行的值、B的j列的值 对应相乘再相加</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>; k++) &#123;<br>sum += <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(i, k) * other.<span class="hljs-title function_">get</span>(k, j);<br>&#125;<br><span class="hljs-comment">// 矩阵设置i行j列的值</span><br>result.<span class="hljs-title function_">set</span>(i, j, sum);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 返回进行变换后的新数组</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">// 全排列</span><br><span class="hljs-title function_">fullPermutate</span>(<span class="hljs-params">nums</span>) &#123;<br><span class="hljs-comment">// 输入：[1,2,3]</span><br><span class="hljs-comment">// 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br><span class="hljs-keyword">let</span> result = [];<br><span class="hljs-comment">// 排列</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">pArr, selectedResult</span>) &#123;<br><span class="hljs-keyword">if</span> (selectedResult.<span class="hljs-property">length</span> === nums.<span class="hljs-property">length</span>) &#123;<br><span class="hljs-comment">// 已找到一组数组 结束当前递归</span><br>result.<span class="hljs-title function_">push</span>(selectedResult);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 遍历数组的每一项</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pArr.<span class="hljs-property">length</span>; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 对上次已获取结果的拷贝</span><br><span class="hljs-keyword">let</span> selectedArr = selectedResult.<span class="hljs-title function_">concat</span>();<br><span class="hljs-comment">// 将这次的结果存入</span><br>selectedArr.<span class="hljs-title function_">push</span>(pArr[i]);<br><span class="hljs-comment">// 做一个克隆 避免相互影响</span><br><span class="hljs-keyword">let</span> newArr = pArr.<span class="hljs-title function_">concat</span>();<br><span class="hljs-comment">// 删掉数组中的当前项</span><br>newArr.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 递归 将数组继续进行全排序</span><br><span class="hljs-title function_">permute</span>(newArr, selectedArr);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 执行排列</span><br><span class="hljs-title function_">permute</span>(nums, []);<br><span class="hljs-comment">// 返回全排列数组</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">// 逆序数 前面的数字比后面数字大的数对数量</span><br><span class="hljs-title function_">reverseNumber</span>(<span class="hljs-params">nums</span>) &#123;<br><span class="hljs-comment">// 输入：[3,2,1]</span><br><span class="hljs-comment">// 输出：3</span><br><span class="hljs-comment">// 默认为0</span><br><span class="hljs-keyword">let</span> reverseNum = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 进行遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-property">length</span>; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 前面的数字比后面数字大 逆序数值+1</span><br><span class="hljs-keyword">if</span> (nums[j] &gt; nums[i]) &#123;<br>reverseNum += <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 返回逆序数</span><br><span class="hljs-keyword">return</span> reverseNum;<br>&#125;<br><span class="hljs-comment">//矩阵行列式 运用全排序和逆序数</span><br><span class="hljs-title function_">det</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 先判断是否为方阵 非方针没有行列式</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;矩阵必须是方阵&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 需要进行全排序的一组数据</span><br><span class="hljs-keyword">let</span> permuteNums = [];<br><span class="hljs-comment">// 根据行数来确定需要进行全排序的数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>; i += <span class="hljs-number">1</span>) &#123;<br>permuteNums.<span class="hljs-title function_">push</span>(i);<br>&#125;<br><span class="hljs-comment">// 获取全排列数组</span><br><span class="hljs-keyword">const</span> fullPermutate = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fullPermutate</span>(permuteNums);<br><span class="hljs-comment">// 遍历全排序数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; fullPermutate.<span class="hljs-property">length</span>; k += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 逆序数 用于确定正负号</span><br><span class="hljs-keyword">const</span> reverseNumber = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">reverseNumber</span>(fullPermutate[k]);<br><span class="hljs-comment">// 矩阵的项相乘所得到的值</span><br><span class="hljs-keyword">let</span> val = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 遍历行</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n = <span class="hljs-number">1</span>; n &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>; n += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 例：a11*a22*a33 a12*a22*a23 固定行，列为全排序数组项 矩阵列从1开始，数组数据从0开始</span><br>val = val * <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(n, fullPermutate[k][n - <span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">// 正负号由-1的逆序数次幂来确定</span><br>result += val * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(-<span class="hljs-number">1</span>, reverseNumber);<br>&#125;<br><span class="hljs-comment">// 返回行列式的值</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">// 转置矩阵 将Aij替换为Aji</span><br><span class="hljs-title function_">transpose</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 转置矩阵 形式上说 m*n的矩阵A的转置是n*m矩阵</span><br><span class="hljs-keyword">let</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>);<br><span class="hljs-comment">// 遍历行和列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>; j += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 判断是否存在对应值</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(j, i) !== <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// 将Aij 替换为Aij</span><br>result.<span class="hljs-title function_">set</span>(i, j, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(j, i));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 返回一个转置矩阵</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">// 余子式 除去Aij所在行和列剩余的矩阵的行列式</span><br><span class="hljs-title function_">surplus</span>(<span class="hljs-params">delRow, delCol</span>) &#123;<br><span class="hljs-comment">// 新的矩阵的data值</span><br><span class="hljs-keyword">let</span> newData = [];<br><span class="hljs-comment">// 遍历行和列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>; j += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// i和j不等于需要被删除的行和列，就把数据push进新的data值</span><br><span class="hljs-keyword">if</span> (j !== delCol &amp;&amp; i !== delRow) &#123;<br>newData.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(i, j));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 设置surplusMatrix矩阵 行列被删除1</span><br><span class="hljs-keyword">const</span> surplusMatrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span> - <span class="hljs-number">1</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span> - <span class="hljs-number">1</span>, newData);<br><span class="hljs-comment">// 返回余子式</span><br><span class="hljs-keyword">return</span> surplusMatrix.<span class="hljs-title function_">det</span>();<br>&#125;<br><span class="hljs-comment">// 伴随矩阵 矩阵中每个元素对应的代数余子式所构成矩阵的转置矩阵</span><br><span class="hljs-title function_">adjoint</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 创建一个0矩阵</span><br><span class="hljs-keyword">let</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>);<br><span class="hljs-comment">// 遍历行和列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>; j += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// val 为Aij 的代数余子式</span><br><span class="hljs-keyword">let</span> val = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(-<span class="hljs-number">1</span>, i + j) * <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">surplus</span>(i, j);<br><span class="hljs-comment">// 设置矩阵内的每个元素</span><br>result.<span class="hljs-title function_">set</span>(i, j, val);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 将矩阵进行转置</span><br><span class="hljs-keyword">return</span> result.<span class="hljs-title function_">transpose</span>();<br>&#125;<br><span class="hljs-comment">// 矩阵求逆 使用伴随矩阵求逆矩阵 A逆 = 1/｜A｜ * A*</span><br><span class="hljs-title function_">inverse</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 判断行列式是否为0 充分且必要条件</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">det</span>() === <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;该矩阵的行列式为0，不存在逆矩阵 &#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 1/｜A｜</span><br><span class="hljs-keyword">const</span> detVal = <span class="hljs-number">1</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">det</span>();<br><span class="hljs-comment">// 得到伴随矩阵</span><br><span class="hljs-keyword">let</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">adjoint</span>();<br><span class="hljs-comment">// 进行遍历行和列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= result.<span class="hljs-property">rows</span>; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= result.<span class="hljs-property">cols</span>; j += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 重新设置矩阵的值 矩阵每项*常数</span><br>result.<span class="hljs-title function_">set</span>(i, j, detVal * result.<span class="hljs-title function_">get</span>(i, j));<br>&#125;<br>&#125;<br><span class="hljs-comment">// 返回一个逆矩阵</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">const</span> A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);<br><span class="hljs-keyword">const</span> B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]);<br><span class="hljs-keyword">const</span> C = A.<span class="hljs-title function_">multiply</span>(B);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(C.<span class="hljs-property">data</span>); <span class="hljs-comment">//输出：[58, 64, 139, 154]</span><br><br><span class="hljs-keyword">const</span> D = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-keyword">const</span> E = D.<span class="hljs-title function_">inverse</span>();<br><span class="hljs-keyword">const</span> F = D.<span class="hljs-title function_">multiply</span>(E);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(E.<span class="hljs-property">data</span>); <span class="hljs-comment">//输出：[1, 0, 0, 0, 0, 0.3333333333333333, 0, 0, 0, 0, 0.25, 0, 0, 0, 0, 0.5]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(F.<span class="hljs-property">data</span>); <span class="hljs-comment">//输出：[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]</span><br><br><span class="hljs-keyword">const</span> G = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, -<span class="hljs-number">4</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">5</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>]);<br><span class="hljs-keyword">const</span> H = G.<span class="hljs-title function_">inverse</span>();<br><span class="hljs-keyword">const</span> I = G.<span class="hljs-title function_">multiply</span>(H);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(H.<span class="hljs-property">data</span>); <span class="hljs-comment">//输出：[2, 2, 3, 1, -1, 0, -1, 2, 1]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(I.<span class="hljs-property">data</span>); <span class="hljs-comment">//输出：[1, 0, 0, 0, 1, 0, 0, 0, 1]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>矩阵相关知识点</title>
    <link href="/2023/02/26/matrix/"/>
    <url>/2023/02/26/matrix/</url>
    
    <content type="html"><![CDATA[<h2 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h2><p>对角线都是 1，其余元素都为 0 的矩阵，如同乘法中的 1</p><h2 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h2><p>图像经过矩阵变换之后的空间的维度</p><h2 id="线性无关"><a href="#线性无关" class="headerlink" title="线性无关"></a>线性无关</h2><p>两个向量不在一条直线上，我们称为线性无关</p><h3 id="列向量"><a href="#列向量" class="headerlink" title="列向量"></a>列向量</h3><p>$$<br>\begin{bmatrix}<br>3 &amp; 2 \<br>1 &amp; 1<br>\end{bmatrix}<br>$$</p><p>列向量[3,1] [2,1]</p><h3 id="列空间"><a href="#列空间" class="headerlink" title="列空间"></a>列空间</h3><p>列向量所列向量所能张成的空间<br>列空间的维度就是秩</p><p>列空间是二维的，秩就是 2</p><p>如果用秩为 1 的矩阵对二维矩阵进行线性变换 实际上是一个二维空间到一维空间的变化</p><h3 id="3-2-的矩阵"><a href="#3-2-的矩阵" class="headerlink" title="3*2 的矩阵"></a>3*2 的矩阵</h3><p>是指 3 行两列的矩阵</p><p>$$<br>\begin{bmatrix}<br>3 &amp; 2 \<br>1 &amp; 1 \<br>6 &amp; 7<br>\end{bmatrix}<br>$$</p><p>秩 &#x3D; 列秩 &#x3D; 行秩</p><h2 id="如何判断是否为满秩"><a href="#如何判断是否为满秩" class="headerlink" title="如何判断是否为满秩"></a>如何判断是否为满秩</h2><p>参考链接：<a href="https://www.zhihu.com/question/21605094">https://www.zhihu.com/question/21605094</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>又学会了</title>
    <link href="/2023/02/09/logs/"/>
    <url>/2023/02/09/logs/</url>
    
    <content type="html"><![CDATA[<h2 id="typeof-和-Instanceof-的区别"><a href="#typeof-和-Instanceof-的区别" class="headerlink" title="typeof 和 Instanceof 的区别"></a>typeof 和 Instanceof 的区别</h2><p>一般来说</p><ul><li>原始类型的值使用 typeof 进行检测<br><code>typeof str3 === &#39;string&#39;</code></li><li>对象值则用 instanceof 来进行检测<br><code>values instanceof Array</code></li></ul><p><a href="https://github.com/febobo/web-interview/issues/65">https://github.com/febobo/web-interview/issues/65</a></p><p><a href="https://stackoverflow.com/questions/45489249/object-prototype-tostring-call-javascript">https://stackoverflow.com/questions/45489249/object-prototype-tostring-call-javascript</a></p><p><a href="https://blog.csdn.net/weixin_42349568/article/details/109006143">https://blog.csdn.net/weixin_42349568/article/details/109006143</a></p><h2 id="控制台-performance-的使用"><a href="#控制台-performance-的使用" class="headerlink" title="控制台 performance 的使用"></a>控制台 performance 的使用</h2><p>感谢大佬同事今天给我的讲解 贴两张一看就懂的图 关于 self Time 和 total Time<br>一开始我不太理解<br>其实总时间就是 &#x3D; 当前函数执行的时间 + 函数处理其他子任务执行的时间<br>这里当前函数执行的时间 就是不包含子任务执行的时间</p><p><img src="/2023/02/09/logs/2023-10-30-23-34-21.png"></p><p><img src="/2023/02/09/logs/2023-10-30-23-37-09.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>零散</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fragmentaryRecord</title>
    <link href="/2023/02/08/fragmentaryRecord/"/>
    <url>/2023/02/08/fragmentaryRecord/</url>
    
    <content type="html"><![CDATA[<h2 id="Mac-homedrew-安装"><a href="#Mac-homedrew-安装" class="headerlink" title="Mac homedrew 安装"></a>Mac homedrew 安装</h2><p>使用大佬写的一键安装脚本</p><p><code>/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; </code></p><p>地址：<a href="https://zhuanlan.zhihu.com/p/111014448">https://zhuanlan.zhihu.com/p/111014448</a></p><h2 id="encodeURI-与-encodeURIComponent"><a href="#encodeURI-与-encodeURIComponent" class="headerlink" title="encodeURI() 与 encodeURIComponent()"></a>encodeURI() 与 encodeURIComponent()</h2><ul><li>元字符<br><code>; , / ? : @ &amp; = + $ # </code></li><li>语义字符<br><code>a-z A-Z 0-9 - _ . ! ~ * &#39; ()</code></li></ul><h3 id="encodeURI"><a href="#encodeURI" class="headerlink" title="encodeURI()"></a>encodeURI()</h3><p>使用：用于转码整个 URL<br>不会对 URL 的元字符和语义字符进行转义</p><h3 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent()"></a>encodeURIComponent()</h3><p>使用：通常指用于转码 URL 组成部分，比如‘？’后面的部分<br>会转码除语义字符串以外所有的字符，即元字符也会被转义</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>无特殊参数的链接，都可以使用 encodeURI()进行转码<br>特殊参数，比如链接里面还有一个回调地址</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 原URL：https://treeu.github.io/?returnURL=“https://treeu.github.io/111”</span><br><br><span class="hljs-string">`https://treeu.github.io/?returnURL=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(</span></span><br><span class="hljs-subst"><span class="hljs-string"><span class="hljs-string">&#x27;https://treeu.github.io/111&#x27;</span></span></span><br><span class="hljs-subst"><span class="hljs-string">)&#125;</span>`</span>;<br><br><span class="hljs-comment">// 输出：&quot;https://treeu.github.io/?returnURL=https%3A%2F%2Ftreeu.github.io%2F111&quot;</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">encodeURI</span>(<span class="hljs-string">&#x27;https://treeu.github.io/啊啊啊&#x27;</span>);<br><br><span class="hljs-comment">// &quot;https://treeu.github.io/%E5%95%8A%E5%95%8A%E5%95%8A 仅转义了中文部分&quot;</span><br><br><span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-string">&#x27;https://treeu.github.io/啊啊啊&#x27;</span>);<br><br><span class="hljs-comment">// &quot;https%3A%2F%2Ftreeu.github.io%2F%E5%95%8A%E5%95%8A%E5%95%8A 中文和斜杠都被转义了&quot;</span><br></code></pre></td></tr></table></figure><h2 id="打开-ssh-的地址"><a href="#打开-ssh-的地址" class="headerlink" title="打开 ssh 的地址"></a>打开 ssh 的地址</h2><p><code>open ~/.ssh</code></p><h2 id="链接远程地址"><a href="#链接远程地址" class="headerlink" title="链接远程地址"></a>链接远程地址</h2><p><code>git add .</code></p><p><code>git commit -m &#39;xxx&#39;</code></p><p><code>git remote add origin git@github.com:TREEU/xxx.git</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>零碎收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读错误处理与调试</title>
    <link href="/2023/02/08/try-catch/"/>
    <url>/2023/02/08/try-catch/</url>
    
    <content type="html"><![CDATA[<h2 id="阅读：错误处理与调试"><a href="#阅读：错误处理与调试" class="headerlink" title="阅读：错误处理与调试"></a>阅读：错误处理与调试</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能出错的代码</span><br>&#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>    <span class="hljs-comment">// 出错之后要做什么</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>);<br>    <span class="hljs-comment">// 最好只依赖message</span><br>    <span class="hljs-comment">// 因为只有message是唯一一个所有浏览器中都有的属性 保证跨平台性</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 无论如何都要执行的代码，即使是上面的模块存在return;</span><br>    <span class="hljs-comment">// 存在finally块则catch为可选块</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><h4 id="Error-基类型"><a href="#Error-基类型" class="headerlink" title="Error 基类型"></a>Error 基类型</h4><p>其他错误类继承该类型，所有的类型都共享相同的属性，该类型主要用于开发者抛出的自定义错误</p><h4 id="InternalError"><a href="#InternalError" class="headerlink" title="InternalError"></a>InternalError</h4><p>底层 javascript 引擎抛出异常时由浏览器抛出<br>例如：递归过多导致了栈溢出</p><h4 id="EvalError"><a href="#EvalError" class="headerlink" title="EvalError"></a>EvalError</h4><p>eval()函数发生异常时候抛出，基本上用不到</p><h4 id="RangeError"><a href="#RangeError" class="headerlink" title="RangeError"></a>RangeError</h4><p>数值越界的时候抛出，<br>例如：<code>let items2 = new Array(Number.MAX_VALUE)</code></p><h4 id="ReferenceError"><a href="#ReferenceError" class="headerlink" title="ReferenceError"></a>ReferenceError</h4><p>会在找不到对象时候发生<br>例如：<code>let obj = x</code></p><h4 id="TypeError-（常见）"><a href="#TypeError-（常见）" class="headerlink" title="TypeError （常见）"></a>TypeError （常见）</h4><p>变量不是预期类型，访问不存在的方法，等等<br>例如：let o &#x3D; new 10</p><h4 id="URIError"><a href="#URIError" class="headerlink" title="URIError"></a>URIError</h4><p>encodeURI()（URL 转码） 或者 decodeURI() 传入了错误的 URI 结构</p><p>可以使用 instanceof 来确定错误的类型，来进行对应的处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//dosomething</span><br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br><span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">TypeError</span>) &#123;<br><span class="hljs-comment">// dosomething</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-try-catch-捕获错误"><a href="#使用-try-catch-捕获错误" class="headerlink" title="使用 try&#x2F;catch 捕获错误"></a>使用 try&#x2F;catch 捕获错误</h3><p>在所有可能发生错误的地方使用 try&#x2F;catch</p><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p><code>thorw new TypeError(&quot;error&quot;)</code></p><p>一般来说，错误应该要在应用程序的底层抛出，目的是为错误提供有关其发生原因的说明，在已知函数无法正确执行的情况下抛出错误</p><h3 id="创建一个自定义类型的错误"><a href="#创建一个自定义类型的错误" class="headerlink" title="创建一个自定义类型的错误"></a>创建一个自定义类型的错误</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">customError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> &#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">message</span>) &#123;<br><span class="hljs-variable language_">super</span>(message);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;CustomError&#x27;</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = message;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">customError</span>(<span class="hljs-string">&#x27;111&#x27;</span>);<br><span class="hljs-comment">// Uncaught CustomError: 11</span><br></code></pre></td></tr></table></figure><h3 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h3><p>任何没有被 try&#x2F;catch 语句处理的错误都会在 window 对象上触发 error 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">message, url, line</span>) =&gt;</span> &#123;<br>consolog.<span class="hljs-title function_">log</span>(message);<br><span class="hljs-keyword">return</span> falss; <span class="hljs-comment">// 阻止浏览器默认报告错误的行为</span><br>&#125;;<br><br><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// true</span><br><span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>错误处理与调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数在前端的应用</title>
    <link href="/2023/02/06/vector/"/>
    <url>/2023/02/06/vector/</url>
    
    <content type="html"><![CDATA[<h2 id="向量是什么"><a href="#向量是什么" class="headerlink" title="向量是什么"></a>向量是什么</h2><ul><li>物理：空间中的箭头，长度&#x2F;方向</li><li>计算机：有序的数字列表</li><li>数学：任何东西 只要相加 or 相乘是有意义的</li></ul><p>经常以原点作为起点</p><p>一个向量的坐标由一对数组成</p><p>$$<br>\begin{bmatrix}<br>-2 \<br>3<br>\end{bmatrix} \tag{x,y}<br>$$</p><p>这组数指导你如何从原点（向量起点）出发到达他的尖端（向量终点）</p><p>三维空间</p><p>$$<br>\begin{bmatrix}<br>-2 \<br>3   \<br>1<br>\end{bmatrix} \tag{x,y,z}<br>$$</p><h2 id="向量加法和数乘"><a href="#向量加法和数乘" class="headerlink" title="向量加法和数乘"></a>向量加法和数乘</h2><h3 id="向量的加法"><a href="#向量的加法" class="headerlink" title="向量的加法"></a>向量的加法</h3><p>将第二个向量的起点移动到第一个向量的终点<br>再画一个向量，从第一个向量的起点出发，指向第二个向量的终点</p><p>此处加法可以抽象为一种运动<br>沿着第一个向量运动，再沿着第二个的方向运动，和直接运动到第三个向量的方向的结果无异</p><p>$$<br>\begin{bmatrix}<br> x1\<br> y1<br>\end{bmatrix}<br>+<br>\begin{bmatrix}<br> x2\<br> y2<br>\end{bmatrix} &#x3D; \begin{bmatrix}<br> x1+x2\<br> x2+y2<br>\end{bmatrix}<br>$$</p><h3 id="向量的数乘"><a href="#向量的数乘" class="headerlink" title="向量的数乘"></a>向量的数乘</h3><p>$$<br>2 * \begin{bmatrix}<br> x1\<br> y1<br>\end{bmatrix} &#x3D; \begin{bmatrix}<br> 2x1\<br> 2y1<br>\end{bmatrix}<br>$$</p><h2 id="基向量"><a href="#基向量" class="headerlink" title="基向量"></a>基向量</h2><p>当我们把一个坐标看作是标量，基向量就是这些标量缩放的对象<br>标量 -&gt; 数字</p><p>选择不同的基向量</p><p>每当我们用数字描述向量时，它都依赖于我们正在使用的基</p><h3 id="线性组合"><a href="#线性组合" class="headerlink" title="线性组合"></a>线性组合</h3><p>两个数乘向量的和被称为这两个向量的线性组合</p><p>$$<br>a\overrightarrow{A} + b\overrightarrow{B}<br>$$</p><h3 id="张成的空间"><a href="#张成的空间" class="headerlink" title="张成的空间"></a>张成的空间</h3><p>所有可以表示为给定向量线性组合的向量的集合</p><p>张成的空间 &#x3D; $$a\overrightarrow{A} + b\overrightarrow{B}$$</p><p>（a 与 b 在实数范围内变动）</p><p><strong>线性代数紧紧围绕加法和数乘</strong></p><p>仅仅通过向量的加法与向量的数乘，你能获得的所有的集合是什么</p><p>二维空间的整个平面<br>共线则是一条直线</p><p>三维向量</p><h3 id="线性相关"><a href="#线性相关" class="headerlink" title="线性相关"></a>线性相关</h3><p>其中一个向量可以表示为其他向量的线性组合 （共线的情况）<br>$$\overrightarrow{w} &#x3D; a\overrightarrow{v}$$<br>(a 取所有值)</p><h2 id="线性无关"><a href="#线性无关" class="headerlink" title="线性无关"></a>线性无关</h2><p>$$\overrightarrow{w} ≠ a\overrightarrow{v}$$<br>(a 取所有值)</p><p>向量如何看作一个点 通常用向量的终点代表一个向量</p><p>考虑一个向量时，看作箭头，考虑多个向量时，看作点</p><h2 id="基的定义"><a href="#基的定义" class="headerlink" title="基的定义"></a>基的定义</h2><p>严格定义： 向量空间的一组基是张成该空间的一个线性无关的向量集</p><p>个人理解：不能共线，应该为不同的方向，如果为同一方向，线性组合就只能代表某条直线或是某个平面内的向量了</p><p>将向量看作每个向量的终点</p><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><ul><li>网格线保持平行且等距分布，并且保持原点不动</li></ul><p>假设现在有一个向量</p><p>$$<br>\begin{bmatrix}<br>-1 \<br>2<br>\end{bmatrix}<br>$$</p><p>基向量</p><p>$$<br>\overrightarrow{i} &#x3D; \begin{bmatrix}<br>1 \<br>0<br>\end{bmatrix}<br>$$</p><p>$$<br>\overrightarrow{j} &#x3D; \begin{bmatrix}<br>0 \<br>1<br>\end{bmatrix}<br>$$</p><p>那么这个向量用基向量表示就是</p><p>$$<br>    \overrightarrow{v} &#x3D; -1 \overrightarrow{i} + 2\overrightarrow{j}<br>$$</p><p>我们现在进行一些变化</p><p>线性变化的重要推论</p><p>$$<br>    transformed\overrightarrow{v} &#x3D; -1 transforamed\overrightarrow{i} + 2transforamed\overrightarrow{j}<br>$$</p><p>只根据变换后的 i 和 j 就能推导出变化后的 v</p><p>我们可以把 i 和 j 这样看</p><p>$$<br>\begin{bmatrix}<br>    1 &amp; 0\<br>    0 &amp; 1<br>\end{bmatrix}<br>$$</p><p>竖着看， x 的坐标，y 的坐标</p><p>那么 线性变换对[5,7]这个向量的变化可以看作</p><p>$$<br>\begin{bmatrix}<br>1 &amp; 0\<br>0 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>5\<br>7<br>\end{bmatrix}<br>&#x3D;5\begin{bmatrix}<br>1\<br>0<br>\end{bmatrix}<br>+<br>7\begin{bmatrix}<br>0\<br>1<br>\end{bmatrix}<br>$$</p><p>公式</p><p>$$<br>\begin{bmatrix}<br>a &amp; b\<br>c &amp; d<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\<br>y<br>\end{bmatrix}<br>&#x3D; x \begin{bmatrix}<br>a\<br>c\end{bmatrix} +y\begin{bmatrix}<br>b\<br>d\end{bmatrix}<br>&#x3D; \begin{bmatrix}<br>ax + cx\<br>by+dy\end{bmatrix}<br>$$</p><h4 id="逆时针旋转-90-度"><a href="#逆时针旋转-90-度" class="headerlink" title="逆时针旋转 90 度"></a>逆时针旋转 90 度</h4><p>$$<br>\begin{bmatrix}<br>0 &amp; -1\<br>1 &amp; 0<br>\end{bmatrix}<br>$$</p><h4 id="剪切-（i-不变-j-顺时针旋转-45-度）"><a href="#剪切-（i-不变-j-顺时针旋转-45-度）" class="headerlink" title="剪切 （i 不变 j 顺时针旋转 45 度）"></a>剪切 （i 不变 j 顺时针旋转 45 度）</h4><p>$$<br>\begin{bmatrix}<br>0 &amp; 1\<br>1 &amp; 1<br>\end{bmatrix}<br>$$</p><p><strong>将矩阵看为空间变化</strong></p><p>矩阵和向量相乘，就是将线性变化作用于那个向量</p><p>$$<br>\begin{bmatrix}<br>0 &amp; 1\<br>1 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>0 &amp; -1\<br>1 &amp; 0\end{bmatrix}<br>&#x3D;\begin{bmatrix}<br>1 &amp; -1\<br>1 &amp; 0<br>\end{bmatrix}<br>$$</p><p>这里我们从右往左来解读这个变换 也就是先旋转然后再剪切</p><h3 id="2-2-矩阵的乘法"><a href="#2-2-矩阵的乘法" class="headerlink" title="2*2 矩阵的乘法"></a>2*2 矩阵的乘法</h3><p>复合变化，从右向左应用</p><p>例：i 帽的变化首先在[1,1],将新的线性变换（左侧）作用于 i 帽，得到变化后的值</p><p>$$<br>\begin{bmatrix}<br>0 &amp; 2\<br>1 &amp; 0<br>\end{bmatrix}<br>\begin{bmatrix}<br>1 &amp; -2\<br>1 &amp; 0<br>\end{bmatrix}<br>$$</p><p>可以拆成</p><p>$$<br>\begin{bmatrix}<br>0 &amp; 2\<br>1 &amp; 0<br>\end{bmatrix}<br>\begin{bmatrix}<br>1\<br>1<br>\end{bmatrix} &#x3D; 1\begin{bmatrix}<br>0\<br>1<br>\end{bmatrix}+1\begin{bmatrix}<br>2\<br>0<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix}<br>2\<br>1<br>\end{bmatrix}<br>$$</p><p>$$<br>\begin{bmatrix}<br>0 &amp; 2\<br>1 &amp; 0<br>\end{bmatrix}<br>\begin{bmatrix}<br>-2\<br>0<br>\end{bmatrix}&#x3D;<br>-2 \begin{bmatrix}<br>0\<br>1<br>\end{bmatrix}+<br>0 \begin{bmatrix}<br>2\<br>0<br>\end{bmatrix}&#x3D;<br>\begin{bmatrix}<br>0\<br>-2<br>\end{bmatrix}<br>$$</p><p>最终我们可以得到结果</p><p>$$<br>\begin{bmatrix}<br>0 &amp; 2\<br>1 &amp; 0<br>\end{bmatrix}<br>\begin{bmatrix}<br>1 &amp; -2\<br>1 &amp; 0<br>\end{bmatrix}&#x3D;\begin{bmatrix}<br>2 &amp; 0\<br>1 &amp; -2<br>\end{bmatrix}<br>$$</p><p>两个矩阵乘积的结果与的顺序相关联</p><p>90 度 剪切 45 度<br>(AB)C &#x3D; A(BC)</p><h3 id="三维空间中的线性变换跟二维类似"><a href="#三维空间中的线性变换跟二维类似" class="headerlink" title="三维空间中的线性变换跟二维类似"></a>三维空间中的线性变换跟二维类似</h3><p>变换的顺序是从右到左 第一个变化&#x2F;第二个变化&#x2F;增加一个竖直空间上的 k 帽<br>也是依次拆开</p><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p>线性变化改变面积的比例<br>det(</p><p>$$<br>\begin{bmatrix}<br>3 &amp; 2\<br>0 &amp; 2<br>\end{bmatrix}<br>$$</p><p>) &#x3D; 6 将这个区域内的面积放大六倍</p><p>行列式为 1&#x2F;2 将这个区域的面积缩小一半</p><p>二维向量 行列式为 0 说明将整个空间压缩在一条直线或者一个点上</p><p>行列式可以为负值</p><p>将一个行列式缩放负数倍意味着什么？</p><p>空间的定向发生了改变 绝对值依然是空间面积变化比例</p><p>比如 一张纸 翻面了</p><p>三位空间中的行列式是体积的缩放比例</p><p>为 0 则意味着体积为 0 也就是一个平面与或者一条直线甚至可能是一个点</p><h2 id="行列式的计算"><a href="#行列式的计算" class="headerlink" title="行列式的计算"></a>行列式的计算</h2><p>det(</p><p>$$<br>\begin{bmatrix}<br>3 &amp; 2\<br>0 &amp; 2<br>\end{bmatrix}<br>$$</p><p>) &#x3D; ad - bc</p><h2 id="行列式的乘积"><a href="#行列式的乘积" class="headerlink" title="行列式的乘积"></a>行列式的乘积</h2><p>det(M1M2) &#x3D; det(M1)det(M2)</p><h2 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h2><p>$$<br>2x + 5y + 3z &#x3D; -3\<br>4x + 0y + 8z &#x3D; 0 \<br>1x + 3y + 0z &#x3D; 2<br>$$</p><p>-&gt;</p><p>$$<br>\begin{bmatrix}<br>2 &amp; 5 &amp; 3\<br>4 &amp; 0 &amp; 8\<br>1 &amp; 3 &amp; 0\<br>\end{bmatrix}<br>\begin{bmatrix}<br>x \<br>y \<br>z<br>\end{bmatrix}&#x3D; \begin{bmatrix}<br>-3 \<br>0 \<br>2<br>\end{bmatrix}<br>$$</p><p>也就是</p><p>$$<br>A\overrightarrow{x} &#x3D; \overrightarrow{v}<br>$$</p><p>A 可以看作是线性变换，也就是向量 x 在进行某种线性变换 A 后可以变为向量</p><p>A 是逆时针旋转 90 度的变换</p><p>$$<br>\begin{bmatrix}<br>0 &amp; -1\<br>1 &amp; 0<br>\end{bmatrix}<br>$$</p><p>$$A^{(-1)}$$逆则是顺时针旋转 90 度的变换</p><p>$$<br>\begin{bmatrix}<br>0 &amp; 1\<br>-1 &amp; 0<br>\end{bmatrix}<br>$$</p><p>两个变化的相继作用在矩阵中称为矩阵的乘法</p><p>$$A^{(-1)}A$$ 是一个“什么都不做”的变化 恒等不变</p><p>$$<br>\begin{bmatrix}<br>1 &amp; 0\<br>0 &amp; 1<br>\end{bmatrix}<br>$$</p><p>$$A^{(-1)}A\overrightarrow{x} &#x3D; A^{(-1)}\overrightarrow{V}$$</p><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><h2 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h2><p>秩代表变化后空间的维度 - 列空间的维度</p><p>当变化的结果为一条直线时，也就是说结果为一维的，秩为 1<br>当变化的结果落在二维平面上，秩为 2</p><h2 id="列空间"><a href="#列空间" class="headerlink" title="列空间"></a>列空间</h2><p>不管是一条直线、还是一个平面还是一个三维空间，所有可能的变换结果的集合都被称为矩阵的列空间</p><p>矩阵的列告诉你基向量变化后的位置<br>变化后的基向量张成的空间就是所有可能的变化结果</p><p>矩阵的列张成的空间</p><p>0 向量一定在列空间中</p><p>变换后落在原点的向量的集合 被称作矩阵的“零空间”或者“核”</p><h2 id="非方阵-在不同维度空间之间的线性变换"><a href="#非方阵-在不同维度空间之间的线性变换" class="headerlink" title="非方阵 在不同维度空间之间的线性变换"></a>非方阵 在不同维度空间之间的线性变换</h2><p>比如一个二维向量到三位向量的变换</p><p>$$<br>\begin{bmatrix}<br>2\<br>7<br>\end{bmatrix}<br>$$</p><p>$$\overrightarrow{v}-&gt;$$</p><p>$$<br>\begin{bmatrix}<br>1\<br>8\<br>2\<br>\end{bmatrix}<br>$$</p><p>解读</p><p>$$<br>\begin{bmatrix}<br>3 &amp; 1\<br>4 &amp; 1\<br>5 &amp; 9\<br>\end{bmatrix}<br>$$</p><p>矩阵有两列代表输入空间有两个基向量<br>有三行表明每一个基向量在变换后都用三个独立的坐标来描述</p><p>$$<br>\begin{bmatrix}<br>3 &amp; 1 &amp; 5\<br>4 &amp; 1 &amp; 9\<br>\end{bmatrix}<br>$$</p><p>矩阵有三列表示元史空间中有三个基向量<br>每个变换后的基向量用两个坐标描述</p><p>所以他们会落在二维空间中</p><p>是一个三维空间到二维空间的变换</p><h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><p>$$<br>\begin{bmatrix}<br>3 \<br>4<br>\end{bmatrix}<br>*<br>\begin{bmatrix}<br>1 \<br>2<br>\end{bmatrix}&#x3D;3<em>1+4</em>2&#x3D;11<br>$$</p><p>$$<br>\overrightarrow{v}<em>\overleftrightarrow{w} &#x3D; \overleftrightarrow{w}在v向量上投影长度</em>\overrightarrow{v}<br>$$</p><p>方向相同 点积为正<br>方向垂直 点积为 0<br>方向相反 点积为负</p><p>点积与顺序无关 也就是不管是 v 向量投影到 w，还是 w 投影到 v 都一样</p><p>点积 -〉 矩阵被投影为一维空间<br>为什么和投影有关系？</p><h2 id="对偶性-？"><a href="#对偶性-？" class="headerlink" title="对偶性 ？"></a>对偶性 ？</h2><h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><p>两个向量 copy 两个向量的副本 围成的四边形的面积称为叉积</p><p>顺序对叉积有影响</p><p>叉积得到的结果是一个向量，这个向量的长度是行列式（面积），方向垂直于平行四边行</p><p>（这个叉积就可以看作是高）</p><h2 id="基向量-1"><a href="#基向量-1" class="headerlink" title="基向量"></a>基向量</h2><p>空间内存两个坐标系，有两个不同的基向量<br>我们的基向量</p><p>$$<br>\begin{bmatrix}<br>1 &amp; 0 \<br>0 &amp; 1<br>\end{bmatrix}<br>$$</p><p>其他人的基向量</p><p>$$<br>A&#x3D;\begin{bmatrix}<br>2 &amp; -1 \<br>1 &amp; 1<br>\end{bmatrix}<br>$$</p><p>将某个向量在我们的坐标系中进行旋转 90 度，在其他人的坐标系中的结果是怎样的？</p><p>将其他人的用我们的基向量进行线性变换来描述</p><p>$$<br>A^{(-1)} \begin{bmatrix}<br>0 &amp; -1 \<br>1 &amp; 0<br>\end{bmatrix}A\begin{bmatrix}<br>x  \<br>y<br>\end{bmatrix}<br>$$</p><p>进行操作之后再用逆矩阵还原回来</p><h2 id="特征向量和特征值"><a href="#特征向量和特征值" class="headerlink" title="特征向量和特征值"></a>特征向量和特征值</h2><p>将矩阵看为线性变化</p><p>变化之后还留在他张成的空间里</p><h3 id="特征值"><a href="#特征值" class="headerlink" title="特征值"></a>特征值</h3><p>$$<br>A\overrightarrow{v} &#x3D; n\overrightarrow{v}<br>$$</p><p>A 为变化的矩阵<br>n 为特征值<br>$\overrightarrow{v}$ 为特征向量</p><p>将 n 转换为对应的矩阵</p><p>$$<br>\begin{bmatrix}<br>n &amp; 0 &amp; 0  \<br>0 &amp; n &amp; 0  \<br>0 &amp; 0 &amp; n \<br>\end{bmatrix}<br>$$</p><p>提出因子 n</p><p>$$<br>n\begin{bmatrix}<br>1 &amp; 0 &amp; 0  \<br>0 &amp; 1 &amp; 0  \<br>0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$$</p><p>&#x2F;&#x2F; 单位矩阵</p><p>$$<br>I&#x3D; \begin{bmatrix}<br>1 &amp; 0 &amp; 0 \<br>0 &amp; 1 &amp; 0 \<br>0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$$</p><p>$$<br>(A - nI)\overrightarrow{v} &#x3D; \overrightarrow{0}<br>$$</p><p>(A - nI)的矩阵</p><p>$$<br>\begin{bmatrix}<br>2-n &amp; 0 &amp; 0 \<br>0 &amp; 3-n &amp; 0 \<br>1 &amp; 0 &amp; 4-n \<br>\end{bmatrix}<br>$$</p><p>找到一个 n 使这个行列式为 0 这个值就是特征值<br>det(A -nI) &#x3D; 0</p><p>? 3*3 或者其他类型的行列式怎么计算</p><h3 id="特征向量"><a href="#特征向量" class="headerlink" title="特征向量"></a>特征向量</h3><p>特征值 n&#x3D;2</p><p>$$<br>\begin{bmatrix}<br>3- n &amp; 1 \<br>0 &amp; 2-n \<br>\end{bmatrix}<br>\begin{bmatrix}<br>x  \<br>y \<br>\end{bmatrix}<br>&#x3D; \begin{bmatrix}<br>0  \<br>0 \<br>\end{bmatrix}<br>$$</p><p>计算得出 x+y &#x3D; 0</p><p>所得到的解全都在由（-1，1）张成的对角线上</p><p>二维线性变换不一定有特征向量<br>比如旋转 90 度</p><p>可能存在只有一个特征值，但是特征向量不止在一条直线上</p><p>比如同时放大两倍</p><p>$$<br>\begin{bmatrix}<br>2&amp; 0 \<br>0 &amp; 2 \<br>\end{bmatrix}<br>$$</p><h3 id="特征基"><a href="#特征基" class="headerlink" title="特征基"></a>特征基</h3><p>如果基向量都是特征向量会发生什么？</p><p>对角矩阵</p><p>$$<br>\begin{bmatrix}<br>2 &amp; 0 &amp; 0 \<br>0 &amp; 3 &amp; 0\<br>0 &amp; 0 &amp; 4 \<br>\end{bmatrix}<br>$$</p><p>所有的基向量都是特征向量<br>矩阵的对角元是它们所属的特征值</p><p>一组基向量（同样是特征向量）构成的集合被称为一组特征基</p><p>如果要计算这个矩阵的 100 次幂<br>先变换到特征基，再那个坐标系中计算 100 次幂</p><p>（也就是说先变化到标准的[0,1][1,0]那个坐标，变换后再用逆变换变回来，这样计算会更容易）</p><p>能张成全空间的特征向量</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://cloud.tencent.com/developer/article/1005103">https://cloud.tencent.com/developer/article/1005103</a></p><p><a href="https://blog.csdn.net/from_the_star/article/details/106427423">https://blog.csdn.net/from_the_star/article/details/106427423</a></p><p><a href="https://zhuanlan.zhihu.com/p/391746508">https://zhuanlan.zhihu.com/p/391746508</a></p><h3 id="逆矩阵的计算"><a href="#逆矩阵的计算" class="headerlink" title="逆矩阵的计算"></a>逆矩阵的计算</h3><p><a href="https://www.shuxuele.com/algebra/matrix-inverse.html">https://www.shuxuele.com/algebra/matrix-inverse.html</a></p><p><a href="https://www.zhihu.com/question/345971704/answer/1624930445">https://www.zhihu.com/question/345971704/answer/1624930445</a></p><h3 id="逆矩阵计算器"><a href="#逆矩阵计算器" class="headerlink" title="逆矩阵计算器"></a>逆矩阵计算器</h3><p><a href="https://matrix.reshish.com/zh/inverse.php">https://matrix.reshish.com/zh/inverse.php</a></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="为什么在向量变换中要使用-4-4-矩阵"><a href="#为什么在向量变换中要使用-4-4-矩阵" class="headerlink" title="为什么在向量变换中要使用 4*4 矩阵"></a>为什么在向量变换中要使用 4*4 矩阵</h3><p>缩放<br>旋转<br>平移 不能用 3*3 矩阵来表示</p><p>$$<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>’线性代数‘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>requestAnimationFrame</title>
    <link href="/2023/02/04/requestAnimationFrame/"/>
    <url>/2023/02/04/requestAnimationFrame/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>浏览器的一个请求动画的API，告诉浏览器你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p><h2 id="早期动画形式"><a href="#早期动画形式" class="headerlink" title="早期动画形式"></a>早期动画形式</h2><p>早期我们使用setTimeout或是setInterval()设置一个间隔时间，来不断的改变图像的位置，来达到一个动画的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javacript">function() &#123;<br>    function updateAnimations() &#123;<br>        doAnimation1();<br>        doAnimation2();<br>    &#125;<br>    setInterval(updateAnimation,100)<br>&#125;()<br><br></code></pre></td></tr></table></figure><ul><li><p>不能保证时间精度<br>  第二个延时参数，这里设置的毫秒延时并不能保证这个代码在什么时候会执行，只是会把回调加到任务队列，加到任务队列后，主线程如果还在被其他任务占用，比如还在处理用户操作，那么回调不会立即执行</p></li><li><p>时间间隔问题<br>  不同设备的屏幕刷新率不同（目前的一般浏览器的刷新屏幕为60Hz，也就是每秒重绘60次，实现平滑动画的最佳时间间隔为1000&#x2F;60，大约17毫秒）浏览器的自身计时器的精度也不一致，浏览器还会切换到后台和不活跃的标签中的计数器进行限流，所以我们设置固定的时间间隔无法达到一个最优效果</p></li></ul><h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><p>requesAnimatonFrame()方法由浏览器来计算正确的时间间隔 </p><p>例如：如果屏幕的刷新率为60Hz，那么时间间隔为1000&#x2F;60，如果屏幕刷新率为70Hz，那么时间间隔则为1000&#x2F;70，</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> progress = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateProgress</span>(<span class="hljs-params"></span>) &#123;<br>   progress += <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span> (progress &lt; <span class="hljs-number">100</span>) &#123;<br>       <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(updateProgress);<br>   &#125;<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(updateProgress)<br></code></pre></td></tr></table></figure><h2 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h2><p>回调函数会被传入一个DOMHighResTimeStamp（doble 类型，双精度,储存毫秒级的时间值）参数，该参数与performance.now()的返回值相同，它表示requestAnimationFrame() 开始去执行回调函数的时刻，（表示下次重绘的时间）</p><p>(拓展：1.JS的数据类型 2.为什么0.1+0.2 !&#x3D;&#x3D; 0.3 3.performance相关接口)</p><h2 id="cancelAnimationFrame"><a href="#cancelAnimationFrame" class="headerlink" title="cancelAnimationFrame"></a>cancelAnimationFrame</h2><pre><code class="hljs">requestAnimationFrame()返回一个请求Id可以用cancelAnimationFrame() 来取消重绘任务<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> requestId = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-function">()=&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;11&#x27;</span>);<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">cancelAnimationFrame</span>(requestId);<br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>javacript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac科学上网</title>
    <link href="/2023/01/27/science-online/"/>
    <url>/2023/01/27/science-online/</url>
    
    <content type="html"><![CDATA[<h2 id="下载-Clash"><a href="#下载-Clash" class="headerlink" title="下载 Clash"></a>下载 Clash</h2><p><strong>链接地址：</strong> <a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">clash 下载地址</a></p><p>选择图中标注进行下载</p><p><img src="/2023/01/27/science-online/2023-01-27-22-06-40.png" alt="scence-online"></p><h2 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h2><p>安装时候会提示</p><p><img src="/2023/01/27/science-online/2023-01-27-21-17-33.png"></p><p>打开系统设置<br><img src="/2023/01/27/science-online/2023-01-27-21-21-35.png"></p><p>在这个地方会有“仍要打开“字样 点击仍要打开 程序就可以正常使用</p><h2 id="机场选择-（科学上网节点服务商）"><a href="#机场选择-（科学上网节点服务商）" class="headerlink" title="机场选择 （科学上网节点服务商）"></a>机场选择 （科学上网节点服务商）</h2><p>这边我选择的是一元机场（便宜，刚使用，目前正常）</p><p><strong>一元机场链接：</strong> <a href="https://一元机场.com/">一元机场</a></p><p><img src="/2023/01/27/science-online/2023-01-27-21-57-50.png"></p><h2 id="clash-配置"><a href="#clash-配置" class="headerlink" title="clash 配置"></a>clash 配置</h2><p>选择一元机场</p><p><img src="/2023/01/27/science-online/2023-01-27-22-02-13.png"></p><p>配置代理 选择一个节点</p><p><img src="/2023/01/27/science-online/2023-01-27-22-05-19.png"></p><p>开启服务</p><p><img src="/2023/01/27/science-online/2023-01-27-22-06-40.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
